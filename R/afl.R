update.afl = function(db, new, ops)
{
  if(missing(ops))
  {
    data("operators", package="scidb", envir=environment())
    ops = operators
    options(scidb.operators = ops)  # for posterity and aflhelp below
  }
  conn = db  # need a reference to the scidb connection in the afl function below
  for(x in new)
  {
    db[[x]] = afl
    # update formal function arguments for nice tab completion help
    i = ops[,1] == x
    if(any(i))
    {
      def = head(ops[i,], 1)
      # XXX very ugly...
      fml = strsplit(gsub("[=:].*", "", gsub("\\|.*", "", gsub(" *", "", gsub("\\]", "", gsub("\\[", "", gsub("\\[.*\\|.*\\]", "", gsub("[+*{})]", "", gsub(".*\\(", "", def[2])))))))), ",")[[1]]
      formals(db[[x]]) = eval(parse(text=sprintf("alist(%s, ...=)", paste(paste(fml ,"="), collapse=", "))))
      class(db[[x]]) = "operator"
      attr(db[[x]], "name") = x
      attr(db[[x]], "conn") = conn
    }
  }
  db
}

#' Evaluate arguments in an AFL expression.
#' @keywords internal
arg = function(x, db, env)
{
# vectors are slightly special
  if(length(x) > 1 && is.vector(x) && class(x)[1] %in% c("character", "numeric", "integer")) x = as.scidb(db, x)
  switch(class(x)[1],
    raw = {ans = as.scidb(db, x); assign(ans@name, ans, envir=env); ans@name},
    matrix = {ans = as.scidb(db, x); assign(ans@name, ans, envir=env); ans@name},
    dgCMatrix = {ans = as.scidb(db, x); assign(ans@name, ans, envir=env); ans@name},
    character = sprintf("%s", x),
    numeric = sprintf("%.16g", x),
    integer = sprintf("%d", x),
    scidb = {assign(x@name, x, envir=env); x@name},
    default = sprintf("%s", x) # verbatim
  )
}

#' Create an AFL expression
#' @param ... AFL expression argument list dynamically generated by \code{update.afl}, but see the note below
#' @note The call list expected to look like: \code{(afl arguments, ...)}
#' @return a \code{\link{scidb}} object
#' @keywords internal function
afl = function(...)
{
  call = eval(as.list(match.call())[[1]])
  .env = new.env()
# why two passes? XXX
  expr = sprintf("%s(%s)", attr(call, "name"), paste(lapply(lapply(as.list(match.call())[-1], function(.x) tryCatch(eval(.x), error=function(e) capture.output(.x))), arg, attr(call, "conn"), .env), collapse=","))
# Some special AFL non-operator expressions don't return arrays
  if(any(grepl(attr(call, "name"), c("remove"), ignore.case=TRUE)))
  {
    return(iquery(attr(call, "conn"), expr))
  }
  ans = scidb(attr(call, "conn"), expr)
  ans@meta$depend = as.list(.env)
  ans
}

#' Display SciDB AFL operator documentation
#' @param topic a SciDB operator or macro name as character string or \code{\link{afl}} object
#' @return displays help
#' @examples
#' \dontrun{
#' s = scidbconnect()
#' aflhelp("list")     # explicitly look up a character string
#' help(s$list)        # same thing via R's \code{help} function
#' }
#' @export
aflhelp = function(topic)
{
  if(is.null(options("scidb.operators")))
  {
    data("operators", package="scidb", envir=environment())
    options(scidb.operators = ops)
  }
  ops = getOption("scidb.operators")
  name = attr(topic, "name")
  if(is.null(name) && is.character(topic)) name = topic
  i = which(name == ops[, 1])
  if(length(i) < 1 || is.na(i)) stop("not found")
  h = sprintf("%s\n\n%s", ops[i, 2], gsub("\\n{2,}", "\n", ops[i, 3]))
  message(h)
}
