#' Update available AFL operators
#'
#' @param db an \code{afl} object (a SciDB database connection returned from \code{\link{scidbconnect}})
#' @param new an optional list of new operators
#' @param ops an optional three-variable data frame with variables name, signature, help, corresponding
#' to the operator names, signatures, and help files (from SciDB Doxygen documentation)
#' @return the updated database object
#' @keywords internal
#' @importFrom utils head
update.afl = function(db, new, ops)
{
  if(missing(ops))
  {
    e = new.env()
    data("operators", package="scidb", envir=e)
    ops = e$operators
    options(scidb.operators = ops)  # for posterity and aflhelp below XXX NO! FIX
  }
  conn = db  # need a reference to the scidb connection in the afl function below
  for(x in new)
  {
    db[[x]] = afl
    i = ops[,1] == x
    # update formal function arguments for nice tab completion help
    if(any(i))
    {
      def = head(ops[i,], 1)
      # XXX very ugly...
      fml = strsplit(gsub("[=:].*", "", gsub("\\|.*", "", gsub(" *", "", gsub("\\]", "", gsub("\\[", "", gsub("\\[.*\\|.*\\]", "", gsub("[+*{})]", "", gsub(".*\\(", "", def[2])))))))), ",")[[1]]
      formals(db[[x]]) = eval(parse(text=sprintf("alist(%s, ...=)", paste(paste(fml ,"="), collapse=", "))))
    }
    class(db[[x]]) = "operator"
    attr(db[[x]], "name") = x
    attr(db[[x]], "conn") = conn
  }
  db
}

#' Evaluate arguments in an AFL expression.
#' @keywords internal
arg = function(x, db, env)
{
# vectors are slightly special
  if(length(x) > 1 && is.vector(x) && class(x)[1] %in% c("character", "numeric", "integer")) x = as.scidb(db, x)
  switch(class(x)[1],
    raw = {ans = as.scidb(db, x); assign(ans@name, ans, envir=env); ans@name},
    matrix = {ans = as.scidb(db, x); assign(ans@name, ans, envir=env); ans@name},
    dgCMatrix = {ans = as.scidb(db, x); assign(ans@name, ans, envir=env); ans@name},
    data.frame = {ans = as.scidb(db, x); assign(ans@name, ans, envir=env); ans@name},
    numeric = sprintf("%.16g", x),
    integer = sprintf("%d", x),
    scidb = {assign(x@name, x, envir=env); x@name},
    gsub("%as%", " as " ,sprintf("%s", x)) # almost verbatim
  )
}

#' Create an AFL expression
#' @param ... AFL expression argument list dynamically generated by \code{update.afl}, but see the note below
#' @note The call list expected to look like: \code{(afl arguments, ...)}
#' @return a \code{\link{scidb}} object
#' @keywords internal function
#' @importFrom utils capture.output
afl = function(...)
{
  call = eval(as.list(match.call())[[1]])
  .env = new.env()
  if(isTRUE(getOption("scidb.tryeval")))
  {
# why two passes? XXX
    expr = sprintf("%s(%s)", attr(call, "name"), paste(lapply(lapply(as.list(match.call())[-1], function(.x) tryCatch({ans = eval(.x); if(inherits(ans, "function")) ans = as.character(ans); ans}, error=function(e) gsub("%as%", " as ", capture.output(.x)))), arg, attr(call, "conn"), .env), collapse=","))
  } else {
    expr = sprintf("%s(%s)", attr(call, "name"), paste(lapply(lapply(as.list(match.call())[-1], function(.x) tryCatch({ans = eval(.x); if(!inherits(ans, "scidb")) stop(); ans}, error=function(e) gsub("%as%", " as ", capture.output(.x)))), arg, attr(call, "conn"), .env), collapse=","))
  }
# Some special AFL non-operator expressions don't return arrays
  if(any(grepl(attr(call, "name"), c("remove"), ignore.case=TRUE)))
  {
    return(iquery(attr(call, "conn"), expr))
  }
  ans = scidb(attr(call, "conn"), expr)
  ans@meta$depend = as.list(.env)
  ans
}

#' Display SciDB AFL operator documentation
#' @param topic a SciDB operator or macro name as character string or \code{\link{afl}} object
#' @return displays help
#' @examples
#' \dontrun{
#' s = scidbconnect()
#' aflhelp("list")     # explicitly look up a character string
#' help(s$list)        # same thing via R's \code{help} function
#' }
#' @importFrom  utils data
#' @export
aflhelp = function(topic)
{
  if(is.null(options("scidb.operators")))
  {
    data("operators", package="scidb", envir=environment())
    options(scidb.operators = ops)
  }
  ops = getOption("scidb.operators")
  name = attr(topic, "name")
  if(is.null(name) && is.character(topic)) name = topic
  i = which(name == ops[, 1])
  if(length(i) < 1 || is.na(i)) stop("not found")
  h = sprintf("%s\n\n%s", ops[i, 2], gsub("\\n{2,}", "\n", ops[i, 3]))
  message(h)
}
