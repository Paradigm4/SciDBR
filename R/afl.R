#' Update available AFL operators
#'
#' @param db an \code{afl} object (a SciDB database connection returned from \code{\link{scidbconnect}})
#' @param new a character vector of operator names
#' @param ops an optional three-variable data frame with variables name, signature, help, corresponding
#' to the operator names, signatures, and help files (from SciDB Doxygen documentation)
#' @return the updated database object
#' @keywords internal
#' @importFrom utils head
update.afl = function(db, new, ops)
{
  if(missing(ops))
  {
    e = new.env()
    data("operators", package="scidb", envir=e)
    ops = e$operators
  }
  conn = db  # need a reference to the scidb connection in the afl function below
  for(x in new)
  {
    db[[x]] = afl
    i = ops[,1] == x
    # update formal function arguments for nice tab completion help
    if(any(i))
    {
      def = head(ops[i,], 1)
      # XXX very ugly...
      fml = strsplit(gsub("[=:].*", "", gsub("\\|.*", "", gsub(" *", "", gsub("\\]", "", gsub("\\[", "", gsub("\\[.*\\|.*\\]", "", gsub("[+*{})]", "", gsub(".*\\(", "", def[2])))))))), ",")[[1]]
      formals(db[[x]]) = eval(parse(text=sprintf("alist(%s, ...=)", paste(paste(fml ,"="), collapse=", "))))
      attr(db[[x]], "help") = def[3]
      attr(db[[x]], "signature") = def[2]
    }
    class(db[[x]]) = "operator"
    attr(db[[x]], "name") = x
    attr(db[[x]], "conn") = conn
  }
  db
}

#' Evaluate arguments in an AFL expression.
#' @keywords internal
arg = function(x, db, env)
{
# vectors are slightly special
  if(length(x) > 1 && is.vector(x) && class(x)[1] %in% c("character", "numeric", "integer")) x = as.scidb(db, x)
  switch(class(x)[1],
    raw = {ans = as.scidb(db, x); assign(ans@name, ans, envir=env); ans@name},
    matrix = {ans = as.scidb(db, x); assign(ans@name, ans, envir=env); ans@name},
    dgCMatrix = {ans = as.scidb(db, x); assign(ans@name, ans, envir=env); ans@name},
    data.frame = {ans = as.scidb(db, x); assign(ans@name, ans, envir=env); ans@name},
    numeric = sprintf("%.16g", x),
    integer = sprintf("%d", x),
    scidb = {assign(x@name, x, envir=env); x@name},
    gsub("%as%", " as " ,sprintf("%s", x)) # almost verbatim default case
  )
}

#' Create an AFL expression
#' @param ... AFL expression argument list dynamically generated by \code{update.afl}, but see the note below
#' @note The call list expected to look like: \code{(afl arguments, ...)}
#' @return a \code{\link{scidb}} object
#' @keywords internal function
#' @importFrom utils capture.output
afl = function(...)
{
  call = eval(as.list(match.call())[[1]])
  .env = new.env()
  expr = sprintf("%s(%s)", attr(call, "name"), paste(
           lapply(
             lapply(as.list(match.call())[-1],
               function(.x) tryCatch({
                   ans = eval(.x)  # allow this to fail, handling error below
                   if(inherits(ans, "scidb") || inherits(ans, "character") || inherits(ans, "integer") || inherits(ans, "numeric") || inherits(ans, "logical")) return(ans)
                   stop()},
                 error=function(e) gsub("%as%", " as ", paste(capture.output(.x), collapse="")))),
             arg, attr(call, "conn"), .env), collapse=","))
# Some special AFL non-operator expressions don't return arrays
  if(any(grepl(attr(call, "name"), c("remove"), ignore.case=TRUE)))
  {
    return(iquery(attr(call, "conn"), expr))
  }
  if(getOption("scidb.debug", FALSE)) message("AFL EXPRESSION: ", expr)
  ans = scidb(attr(call, "conn"), expr)
  ans@meta$depend = as.list(.env)
  ans
}

#' Display SciDB AFL operator documentation
#' @param topic an \code{\link{afl}} object from a SciDB database connection, or optionally a character string name
#' @param optional database connection from \code{\link{scidbconnect}} (only needed when \code{topic} is a character string)
#' @return displays help
#' @examples
#' \dontrun{
#' s = scidbconnect()
#' aflhelp("list")     # explicitly look up a character string
#' help(s$list)        # same thing via R's \code{help} function
#' }
#' @importFrom  utils data
#' @export
aflhelp = function(topic, db)
{
  if(is.character(topic))
  {
    if(missing(db)) stop("character topics require a database connection argument")
    topic = db[[topic]]
  }
  h = sprintf("%s\n\n%s", attr(topic, "signature"), gsub("\\n{2,}", "\n", attr(topic, "help")))
  message(h)
}
