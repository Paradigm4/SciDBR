update.afl = function(db, new, ops)
{
  if(missing(ops))
  {
    data("operators", package="scidb", envir=environment())
    ops = operators
    options(scidb.operators = ops)  # for posterity and aflhelp below
  }
  conn = db  # need a reference to the scidb connection in the afl function below
  for(x in new)
  {
    db[[x]] = afl
    # update formal function arguments for nice tab completion help
    i = ops[,1] == x
    if(any(i))
    {
      def = head(ops[i,], 1)
      # XXX very ugly...
      fml = strsplit(gsub("[=:].*", "", gsub("\\|.*", "", gsub(" *", "", gsub("\\]", "", gsub("\\[", "", gsub("\\[.*\\|.*\\]", "", gsub("[+*{})]", "", gsub(".*\\(", "", def[2])))))))), ",")[[1]]
      formals(db[[x]]) = eval(parse(text=sprintf("alist(%s, ...=)", paste(paste(fml ,"="), collapse=", "))))
      class(db[[x]]) = "operator"
      attr(db[[x]], "name") = x
      attr(db[[x]], "conn") = conn
    }
  }
  db
}

arg = function(x)
{
  switch(class(x),
    character = sprintf("'%s'", x),
    numeric = sprintf("%.16g", x),
    integer = sprintf("%d", x),
    scidb = x@name
  )
}

#' Create an AFL expression
#' @param ... AFL expression argument list dynamically generated by \code{update.afl}, but see the note below
#' @note The call list expected to look like: \code{(afl arguments, ...)}
#' @return a \code{\link{scidb}} object
#' @keywords internal function
afl = function(...)
{
  call = eval(as.list(match.call())[[1]])
  expr = sprintf("%s(%s)", attr(call, "name"), paste(lapply(match.call()[-1], arg), collapse=","))
  scidb(attr(call, "conn"), expr)
}

#' Display SciDB AFL operator documentation
#' @param topic a SciDB operator or macro name as character string or \code{\link{afl}} object
#' @return displays help
#' @examples
#' \dontrun{
#' s = scidbconnect()
#' aflhelp("list")     # explicitly look up a character string
#' help(s$list)        # same thing via R's \code{help} function
#' }
#' @export
aflhelp = function(topic)
{
  if(is.null(options("scidb.operators")))
  {
    data("operators", package="scidb", envir=environment())
    options(scidb.operators = ops)
  }
  ops = getOption("scidb.operators")
  name = attr(topic, "name")
  if(is.null(name) && is.character(topic)) name = topic
  i = which(name == ops[, 1])
  if(length(i) < 1 || is.na(i)) stop("not found")
  h = sprintf("%s\n\n%s", ops[i, 2], gsub("\\n{2,}", "\n", ops[i, 3]))
  message(h)
}
