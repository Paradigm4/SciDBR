<html>
<head>
<link rel="stylesheet" type="text/css" href="stylesheets/R.css" media="screen" />
</head>
<body>

<h1>R Documentation for the `scidb` Package</h1>
<h2>Table of Contents</h2>
<div id="nav">
</div>
<hr>


<table width="100%" summary="page for aggregate-methods"><tr><td>aggregate-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Methods for Function <code>aggregate</code> in Package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p>Aggregate a SciDB array object grouped by a subset of its dimensions and/or attributes.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
aggregate(x, by, FUN, eval, window, variable_window, unpack)
## S4 method for signature 'scidbdf'
aggregate(x, by, FUN, eval, window, variable_window, unpack)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code> or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>by</code></td>
<td>
<p>(Optional) Either a single character string or a list of array dimension and/or attribute names to group by; or a SciDB array reference object to group by. Not required for <code>windowed</code> and grand aggregates&ndash;see details.</p>
</td></tr>
<tr valign="top"><td><code>FUN</code></td>
<td>
<p>A character string representing a SciDB aggregation expression
or a reduction function.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
<tr valign="top"><td><code>window</code></td>
<td>
<p>(Optional) If specified, perform a moving window aggregate along the specified coordinate windows&ndash;see details below.</p>
</td></tr>
<tr valign="top"><td><code>variable_window</code></td>
<td>
<p>(Optional) If specified, perform a moving window aggregate over successive data values along the coordinate dimension axis specified by <code>by</code>&ndash;see details below.</p>
</td></tr>
<tr valign="top"><td><code>unpack</code></td>
<td>
<p>(Optional) If TRUE, return an unpacked SciDB result as a
scidbdf dataframe-like object. It's sometimes useful to
set this to FALSE if the aggregated result needs to be
joined with another array. Default=FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Group the <code>scidb</code>, or <code>scidbdf</code> array object <code>x</code> by dimensions
and/or attributes in the array.  applying the valid SciDB aggregation function
<code>FUN</code> expressed as a character string to the groups. Set eval to TRUE to
execute the aggregation and return a scidb object; set eval to FALSE to return
an unevaluated SciDB array promise, which is essentially a character string
describing the query that can be composed with other SciDB package functions.
</p>
<p>If an R reduction function is speciied for <code>FUN</code>, it will be
transliterated to a SciDB aggregate.
</p>
<p>The <code>by</code> argument must be a list of dimension names and/or attribute names
in the array <code>x</code> to group by, or a SciDB array reference object.  If
<code>by</code> is not specified and one of the <code>window</code> options is not
specified, then a grand aggregate is performed over all values in the array.
</p>
<p>The argument <code>by</code> may be a list of dimension names and/or attributes of the
array <code>x</code>. Attributes that are not of type int64 will be 'factorized' first
and replaced by enumerated int64 values that indicate each unique level (this
requires SciDB 13.6 or higher).
</p>
<p>When <code>by</code> is a SciDB array it must contain one or more common dimensions
with <code>x</code>.  The two arrays will be joined (using SciDB
<code>cross_join(x,by)</code> and the resulting array will be grouped by the
attributes in the <code>by</code> array. This is similar to the usual R data.frame
aggregate method.
</p>
<p>Perform moving window aggregates by specifying the optional <code>window</code> or
<code>variable_window</code> arguments. Use <code>window</code> to compute the aggregate
expression along a moving window specified along each coordinate axis as
<code>window=c(dimension_1_low, dim_1_high, dim_2_low,_dim_2_high, ...</code>.
Moving window aggregates along coordinates may be applied in multiple
dimensions.
</p>
<p>Use <code>variable_window</code> to perform moving window aggregates over data
values in a single dimension specified by the <code>by</code> argument. See below
for examples. Moving window aggregates along data values are restricted
to a single array dimension.
</p>


<h3>Value</h3>

<p>A <code>scidbdf</code> reference object. </p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Create a copy of the iris data frame in a 1-d SciDB array named "iris."
# Note that SciDB attribute names will be changed to conform to SciDB
# naming convention.
x &lt;- as.scidb(iris,name="iris")

# Compute averages of each variable grouped by Species
a &lt;- aggregate(x, by="Species", FUN=mean)

# Aggregation by an auxillary vector (which in this example comes from
# an R data frame)--also note any valid SciDB aggregation expression may
# be used:
y &lt;- as.scidb(data.frame(sample(1:4,150,replace=TRUE)))
a &lt;- aggregate(x, by=y, FUN="avg(Petal_Width) as apw, min(Sepal_Length) as msl")

# Use the window argument to perform moving window aggregates along coordinate
# systems. You need to supply a window across all the array dimesions.
set.seed(1)
A &lt;- as.scidb(matrix(rnorm(20),nrow=5))
# Compute a moving window aggregate only along the rows summing two rows at
# a time (returning result to R). The notation (0,1,0,0) means apply the
# aggregate over the current row (0) and (1) following row, and just over
# the current column (that is, a window size of one).
aggregate(A,FUN="sum(val)",window=c(0,1,0,0))[]
# The above aggregate is equivalent to, for example:
apply(a,2,function(x) x+c(x[-1],0))

# Moving windows using the window= argument run along array coordinates.
# Moving windows using the variable_window= argument run along data values,
# skipping over empty array cells. The next example illustrates the
# difference.

# First, create an array with empty values:
B &lt;- A&gt;0
# Here is what B looks like:
B[]
# Now, run a moving window aggregate along the rows with window just like
# the above example:
aggregate(B,FUN="sum(val)",window=c(0,1,0,0))[]
# And now, a moving window along only the data values down the rows, note
# that we need to specify the dimension with by=:
aggregate(B,by="i",FUN="sum(val)",variable_window=c(0,1))[]

## End(Not run)
</pre>



<table width="100%" summary="page for all.equal"><tr><td>all.equal</td><td align="right">R Documentation</td></tr></table>

<h2>
Test if two SciDB arrays are equal in content
</h2>

<h3>Description</h3>

<p>Test if two SciDB arrays are equal in content, ignoring
SciDB chunk partitioning and overlap differences.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'scidb'
all.equal(target, current, ...)
## S3 method for class 'scidbdf'
all.equal(target, current, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>target</code></td>
<td>
<p> a <code>scidb</code> or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>current</code></td>
<td>
<p> a <code>scidb</code> or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p> optional arguments that might be used in a future version.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return <code>TRUE</code> if the <code>target</code> SciDB array has the same dimensions,
same attributes and types and same data at the same coordinates as the
<code>current</code> array.  Return <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>A. Poliakov &lt;apoliakov@paradigm4&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Let's build a constant-valued 10x10 array:
a &lt;- build(pi, c(10,10), chunksize=c(5,7))

# The array is equal to itself!
all.equal(a,a)    # (returns TRUE)

# Let's build an identically-shaped and valued array but with different
# array chunk partitioning and overlap:
b &lt;- build(pi, c(10,10), chunksize=c(9,10), overlap=c(1,1))

# all.equal does not care about SciDB chunk sizes or overlap differences:
all.equal(a,b)    # (returns TRUE)

# But differences in value or dimension matter:
all.equal(a, b*2)  # (returns FALSE)

## End(Not run)
</pre>


<table width="100%" summary="page for antijoin"><tr><td>antijoin</td><td align="right">R Documentation</td></tr></table>

<h2>
antijoin
</h2>

<h3>Description</h3>

<p>Given two SciDB arrays of same dimensionality, return any coordinates that do
NOT join.
</p>


<h3>Usage</h3>

<pre>
antijoin( array1, array2 )
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>array1</code></td>
<td>
<p> a <code>scidb</code> array or <code>scidbdf</code> data frame object.</p>
</td></tr>
<tr valign="top"><td><code>array2</code></td>
<td>
<p> a <code>scidb</code> array or <code>scidbdf</code> data frame object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> is returned when the two arrays join in all coordinates.
Otherwise, a <code>scidb</code> array is returned such that for all coordinates, the
single attribute shall equal to 1 if those coordinates exist only in
<code>array1</code>, or 2 if those coordinates exist only in <code>array2</code>.
</p>


<h3>Author(s)</h3>

<p>A. Poliakov &lt;apoliakov@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
set.seed(1)
# Generate sparse SciDB arrays
a &lt;- as.scidb(Matrix::sparseMatrix(
               sample(10,100,replace=TRUE),sample(10,100,replace=TRUE),x=runif(100)))
b &lt;- as.scidb(Matrix::sparseMatrix(
               sample(10,100,replace=TRUE),sample(10,100,replace=TRUE),x=runif(100)))
antijoin(a,b)[]

# Output looks like:
# [1,] 2 . . 1 2 1 . . . 2
# [2,] 2 . 2 2 2 1 1 1 2 2
# [3,] 2 . . 2 . 2 . . . 1
# [4,] . 2 1 . . . . 1 . 2
# [5,] . . . . . 1 . . . 2
# [6,] 1 2 . . 2 2 . 1 . 2
# [7,] . 1 . 1 . 1 . 1 . 1
# [8,] 2 . 1 . 1 1 1 . . .
# [9,] 2 . 1 . 2 . . 2 1 .
#[10,] 2 . . . 2 . 2 2 . .

## End(Not run)</pre>


<table width="100%" summary="page for as.scidb"><tr><td>as.scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
Upload an R vector, matrix or data.frame to a SciDB array.
</h2>

<h3>Description</h3>

<p>Upload an R vector, matrix or data.frame into SciDB, returning a reference scidb object.
</p>


<h3>Usage</h3>

<pre>
as.scidb(X, name = tmpnam(), chunksize, overlap, start, chunkSize, gc=TRUE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p> A vector, matrix or sparse matrix of double-precision floating point values or a data.frame. </p>
</td></tr>
<tr valign="top"><td><code>name</code></td>
<td>
<p> The name of the SciDB array to create.  </p>
</td></tr>
<tr valign="top"><td><code>chunksize</code></td>
<td>
<p>A vector of optional SciDB array chunk sizes (a vector of length 1 for data frames and vectors, length 2 for matrices)</p>
</td></tr>
<tr valign="top"><td><code>overlap</code></td>
<td>
<p>(Not yet supported)</p>
</td></tr>
<tr valign="top"><td><code>start</code></td>
<td>
<p>A vector of SciDB array starting dimension numeric index value or values.</p>
</td></tr>
<tr valign="top"><td><code>chunkSize</code></td>
<td>
<p>(Same as <code>chunksize</code> argument, for backwards compatibility &ndash; use <code>chunksize</code> instead)</p>
</td></tr>
<tr valign="top"><td><code>gc</code></td>
<td>
<p>Set to TRUE to remove SciDB array when R object is garbage collected or R exists. FALSE means SciDB array persists.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p> additional arguments to pass to <code>df2scidb</code> (see <code>df2scidb</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used with a matrix  or vector argument,
the <code>as.scidb</code> function creates a single-attribute SciDB array named
<code>name</code> and copies the data from <code>X</code> into it, returning a <code>scidb</code>
object reference to the new array. The SciDB array will be 1-D if <code>X</code> is a
vector, and 2-D if <code>X</code> is a matrix. Data are transferred using a binary
representation.
</p>
<p>If <code>X</code> is a data.frame, then <code>as.scidb</code> creates a one-dimensional
multi-attribute SciDB array, with SciDB attributes representing each column
of the data.frame. A utitlity function called <code>df2scidb</code> is used for
data.frame uploads&ndash;the functions <code>as.scidb</code> and df2scidb are equivalent
in this use case. Note that data frame data are transferred using a text
representation.
</p>
<p>This function supports double-precision, integer (32-bit), logical, and single-character
array attribute types.
</p>


<h3>Value</h3>

<p>A <code>scidb</code> reference object. </p>


<h3>Note</h3>

<p>The <code>as.scidb</code> function is not a very efficient way to upload lots of data
to SciDB. Consider using the SciDB parallel bulk loader tools for that.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
<code>df2scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
X &lt;- matrix(runif(20),5)
A &lt;- as.scidb(X)
as.scidb(iris)
scidblist()
print(A)

## End(Not run)
</pre>


<table width="100%" summary="page for attribute_rename"><tr><td>attribute_rename</td><td align="right">R Documentation</td></tr></table>

<h2>
Rename an attribute.
</h2>

<h3>Description</h3>

<p>Rename a SciDB array attribute.
</p>


<h3>Usage</h3>

<pre>
attribute_rename(x, old, `new`, `eval`=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code>  or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>old</code></td>
<td>
<p>A character string representation of the old attribute name.</p>
</td></tr>
<tr valign="top"><td><code>new</code></td>
<td>
<p>A character string representation of the new attribute name.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>scidb</code> or <code>scidbdf</code> object.
</p>


<h3>Note</h3>

<p>If you don't specify the <code>old</code> argument, it will default to the attribute
names of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
<code>dimension_rename</code>
<code>cast</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- as.scidb(iris)
y &lt;- attribute_rename(x, "Species", "Group")

print(head(y))

## End(Not run)</pre>


<table width="100%" summary="page for bernoulli"><tr><td>bernoulli</td><td align="right">R Documentation</td></tr></table>

<h2>
Sample from populated cells in a SciDB array.
</h2>

<h3>Description</h3>

<p>Return a sparse SciDB array that samples from populated cells in the SciDB array <code>x</code>.
</p>


<h3>Usage</h3>

<pre>
bernoulli (x, prob, seed=sample(2^32 - 1 - 2^31, 1))
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code>  or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>prob</code></td>
<td>
<p>A number in the interval (0, 1] 
indicating the probability of a cell being included
in the sample.</p>
</td></tr>
<tr valign="top"><td><code>seed</code></td>
<td>
<p>A 32-bit signed integer random seed value for SciDB's bernoulli operator.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This R function corresponds to SciDB's <code>bernoulli</code> operator.
</p>
<p>For each non-empty cell in the input array <code>x</code>, generate a number
sampled fom a uniform random distribution. If the number is less than
or equal to <code>prob</code>, then include the cell in the output array.
</p>


<h3>Value</h3>

<p>A new sparse <code>scidb</code> or <code>scidbdf</code> object.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- build("i+j", c(10,10), type="double")
y &lt;- bernoulli(x, 0.5) # Sample about 1/2 the cells of x
count(y)

# Note that y is lazily evaluated *and* its value is probablistic. Thus
# its value will change upon each evaluation. For example:
count(y)
count(y)

# Use scidbeval to force evaluation of y once and for all:
y &lt;- scidbeval(y)
count(y)
count(y)

## End(Not run)</pre>


<table width="100%" summary="page for between"><tr><td>between</td><td align="right">R Documentation</td></tr></table>

<h2>
between
</h2>

<h3>Description</h3>

<p>Use <code>between</code> to select contiguous subarrays in indexing
operations. The <code>between</code> function would not normally be used directly
but rather inside bracket indexing operations as shown in the example.
This function is designed to support efficient indexing of contiguous
subarrays for arrays with non-integer dimensions.
</p>


<h3>Usage</h3>

<pre>
between(a,b)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>a</code></td>
<td>
<p>A SciDB array range bound (numeric or string in the case of non-integer dimension)</p>
</td></tr>
<tr valign="top"><td><code>b</code></td>
<td>
<p>A SciDB array range bound (numeric or string in the case of non-integer dimension)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that evaluates to a list of the specified bounds.
</p>


<h3>Note</h3>

<p>Between requires argument values that correspond to the array dimension
types (no dimension casting is performed).
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Upload data to create a 10x10 SciDB matrix
A &lt;- as.scidb(matrix(rnorm(100),10))
# The following are equivalent, but between avoids creating an
# indexing vector:
A[0:4,][]
A[between(0,4),][]

## End(Not run)</pre>


<table width="100%" summary="page for bind"><tr><td>bind</td><td align="right">R Documentation</td></tr></table>

<h2>
bind
</h2>

<h3>Description</h3>

<p>The <code>bind</code> function is a wrapper to the SciDB 'apply' operator.
We chose the name 'bind' as this function most closely matches the
concept of the R <code>cbind</code> function in data frame contexts.
</p>
<p>Similarly to <code>cbind</code>, the <code>bind</code> function adds a new
variable (a.k.a. SciDB 'attribute') to a SciDB array.
</p>


<h3>Usage</h3>

<pre>
bind(X, name, FUN, eval)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>A scidb or scidbdf object</p>
</td></tr>
<tr valign="top"><td><code>name</code></td>
<td>
<p>A character name for the new attribute</p>
</td></tr>
<tr valign="top"><td><code>FUN</code></td>
<td>
<p>A SciDB function or expression that defines the values for the new attribute (character)</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>scidbdf</code> object.
</p>


<h3>Note</h3>

<p>Use <code>eval=FALSE</code> to defer expression evaluation for efficiency.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- as.scidb(iris)
y &lt;- bind(x, "prod", "Petal_Length * Petal_Width")

# The new scidbdf object y contains a new variable named 'prod':
print(head(y))

## End(Not run)</pre>


<table width="100%" summary="page for build"><tr><td>build</td><td align="right">R Documentation</td></tr></table>

<h2>
build
</h2>

<h3>Description</h3>

<p>The <code>build</code> function is a wrapper to the SciDB 'build' operator.
Operation is similar to the R <code>matrix</code> and <code>array</code> functions.
It creates a new single-attribute SciDB array based on the specified parameters.
</p>


<h3>Usage</h3>

<pre>
build(data, dim, names, type, start, name, chunksize, overlap, gc=TRUE, `eval`)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>
<p>A valid SciDB expression (expressed as a character string) or constant to fill the array.</p>
</td></tr>
<tr valign="top"><td><code>dim</code></td>
<td>
<p>A vector of dimension lengths.</p>
</td></tr>
<tr valign="top"><td><code>names</code></td>
<td>
<p>An optional vector of attribute and dimension names. Default attribute name is 'val' and the dimension names are labeled i,j,... by default.</p>
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>
<p>The SciDB type of the array attribute.</p>
</td></tr>
<tr valign="top"><td><code>start</code></td>
<td>
<p>An optional vector of starting dimension coordinate indices. Must match the length of the dim vector.</p>
</td></tr>
<tr valign="top"><td><code>name</code></td>
<td>
<p>Optional name of the SciDB array. An automatically generated name is used by default.</p>
</td></tr>
<tr valign="top"><td><code>chunksize</code></td>
<td>
<p>An optional vector of dimension chunk sizes. Must match the length of the dim vector.</p>
</td></tr>
<tr valign="top"><td><code>overlap</code></td>
<td>
<p>An optional vector of dimension overlap values. Must match the length of the dim vector.</p>
</td></tr>
<tr valign="top"><td><code>gc</code></td>
<td>
<p>gc=TRUE (the default) removes the array when corresponding R objects are garbage collected. Set gc=FALSE to preserve arrays.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>scidb</code> object.
</p>


<h3>Note</h3>

<p>Use <code>eval=FALSE</code> to defer expression evaluation for efficiency.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
y &lt;- build(pi, c(5,3))
print(head(y))

## End(Not run)</pre>


<table width="100%" summary="page for cast"><tr><td>cast</td><td align="right">R Documentation</td></tr></table>

<h2>
Low-level SciDB cast operator
</h2>

<h3>Description</h3>

<p>Apply the low-level SciDB cast operator to a SciDB array.
</p>


<h3>Usage</h3>

<pre>
cast(x, schema, `eval`=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code>  or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>schema</code></td>
<td>
<p>A character string representation of a SciDB array schema.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>scidb</code> or <code>scidbdf</code> object.
</p>


<h3>Note</h3>

<p>The low-level SciDB cast operator can be used to change attribute and dimension names of an arary.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
<code>attribute_rename</code>
<code>dimension_rename</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- as.scidb(iris)
y &lt;- cast(x,"&lt;a:double,b:double,c:double,e:double,f:string&gt;[row=1:150,150,0]")

print(head(y))

## End(Not run)</pre>


<table width="100%" summary="page for chunk_map"><tr><td>chunk_map</td><td align="right">R Documentation</td></tr></table>

<h2>
chunk_map
</h2>

<h3>Description</h3>

<p>Display a map of SciDB array partition counts
</p>


<h3>Usage</h3>

<pre>
chunk_map(array)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>array</code></td>
<td>
<p>(Optional character string)  a <code>scidb</code> array or <code>scidbdf</code> object or array name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specify the optional array argument to get a more specific chunk map
list for a particular array and all its versios. If specified, <code>array</code>
must refer to a stored (named) SciDB array.
</p>


<h3>Value</h3>

<p>A data frame with a list of chunk counts and instance mapping for each
chunk of the specified array and all its versions,
or a summary of overall chunk map statistics
for all arrays if <code>array</code> is not specified.
</p>


<h3>Author(s)</h3>

<p>A. Poliakov &lt;apoliakov@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
library("scidb")
scidbconnect()

# Chunk map statistics for all arrays:
chunk_map()

# Chunk map statistics for a specific array:

## End(Not run)</pre>


<table width="100%" summary="page for c-methods"><tr><td>c-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Concatenate SciDB arrays</h2>

<h3>Description</h3>

<p>Concatenate SciDB arrays along one coordinate axis.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidbdf'
c(x,y,`eval`=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p>A <code>scidbdf</code> object with the same attribute pattern as <code>x</code>.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Concatenate the SciDB arrays along their single dimension. The output array
will include the entries of array <code>y</code> below the entries of <code>x</code>.
The input arrays must have the same number of attributes and attribute types.
</p>


<h3>Value</h3>

<p>A <code>scidbdf</code> reference object. </p>


<h3>Note</h3>

<p>This method will soon be extended to n-d arrays and to accept a list of more
than two input arrays.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
data("iris")
x &lt;- as.scidb(iris)
c(x,x)

## End(Not run)
</pre>


<table width="100%" summary="page for comparison-methods"><tr><td>comparison-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Masking comparison methods from package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p>The binary operators described here perform comparison operations that
return a sparse SciDB array of the same shape as the input array but
only containing entries where the comparison evaluates to TRUE.
</p>
<p>Compare this with standard R comparison operators on SciDB arrays,
that return an array populated with TRUE or FALSE values.
</p>
<p>Masked comparison arrays can be used to efficiently index other
SciDB arrays.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
x %&lt;% y
## S4 method for signature 'scidbdf'
x %&lt;% y
## S4 method for signature 'scidb'
x %&gt;% y
## S4 method for signature 'scidbdf'
x %&gt;% y
## S4 method for signature 'scidb'
x %&lt;=% y
## S4 method for signature 'scidbdf'
x %&lt;=% y
## S4 method for signature 'scidb'
x %&gt;=% y
## S4 method for signature 'scidbdf'
x %&gt;=% y
## S4 method for signature 'scidb'
x %==% y
## S4 method for signature 'scidbdf'
x %==% y
## S4 method for signature 'scidb'
x %!=% y
## S4 method for signature 'scidbdf'
x %!=% y
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code> or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p>A scalar value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The comparisons outlined here are limited to scalars. A future
version will include element-wise comparison between arrays. For now,
use the <code>bind</code> and <code>merge</code> functions to manually perform
element-wise comparisons.
</p>
<p>The standard R comparison operators by convention return an array of the
same size as <code>x</code> with <code>TRUE</code> or <code>FALSE</code> values indicating
the result of the comparison for each cell. That kind of output is
especially useful in subsequent aggregations, for example.
</p>
<p>The alternate comparison methods outlined here return an array of the
same shape as <code>x</code>, but masked to only contain values in cells
where the
condition evaluates to <code>TRUE</code>. Remaining cells are empty.
This kind of comparison method is useful to quickly extract the values
that meet the condition, and also to use the masked array as an
index to subset other SciDB arrays.
</p>
<p>The examples below illustrate each kind of comparison operator.
</p>


<h3>Value</h3>

<p>A <code>scidb</code> or <code>scidbdf</code> array of the same shape as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
&gt; set.seed(1)
&gt; x=as.scidb(rnorm(10))
&gt; x[]
# [1] -0.6264538  0.1836433 -0.8356286  1.5952808  0.3295078 -0.8204684
# [7]  0.4874291  0.7383247  0.5757814 -0.3053884
&gt; (x &lt; 0)[]
# [1]  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE
&gt; (x 
#sparse vector (nnz/length = 4/10) of class "dsparseVector"
# [1] -0.6264538          . -0.8356286          .          . -0.8204684
# [7]          .          .          . -0.3053884

# 
&gt; Filter("val &lt; 0", x)[]
#sparse vector (nnz/length = 4/10) of class "dsparseVector"
# [1] -0.6264538          . -0.8356286          .          . -0.8204684
# [7]          .          .          . -0.3053884

# Sparse filtered output is useful to use to index SciDB arrays. The next
# example selects just the entries of the array that meet the condition:
&gt; x[x 
# [1] -0.6264538 -0.8356286 -0.8204684 -0.3053884

# The TRUE/FALSE output array is useful to aggregate by groups defined
# by the condition. The next example computes the mean of the entries
# that are less than zero, and the mean of the entries that are greater
# than or equal to zero:
&gt; aggregate(x, by=(x&lt;0), FUN=mean)[]
#  condition_index    val_avg condition
#0               0  0.6516612     false
#1               1 -0.6469848      true

## End(Not run)</pre>


<table width="100%" summary="page for cumulate"><tr><td>cumulate</td><td align="right">R Documentation</td></tr></table>

<h2>
cumulate
</h2>

<h3>Description</h3>

<p>Use <code>cumulate</code> function to compute running operations along data,
for example cumulative sums.
</p>


<h3>Usage</h3>

<pre>
cumulate(x, expression, dimension, eval)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A scidb or scidbdf object</p>
</td></tr>
<tr valign="top"><td><code>expression</code></td>
<td>
<p>Any valid SciDB aggregate expression, expressed as a character string</p>
</td></tr>
<tr valign="top"><td><code>dimension</code></td>
<td>
<p>An optional array dimension name (character) to run along. The default is to use the first dimension.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>scidb</code> object.
</p>


<h3>Note</h3>

<p>Use <code>eval=FALSE</code> to defer expression evaluation for efficiency.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>aggregate</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- as.scidb(iris)
y &lt;- cumulate(x, "sum(Petal_Width)")

print(head(y))

## End(Not run)</pre>


<table width="100%" summary="page for df2scidb"><tr><td>df2scidb</td><td align="right">R Documentation</td></tr></table>

<h2>Copy a data frame into a SciDB array.</h2>

<h3>Description</h3>

<p>Copy a data frame into a new 1-D SciDB array.
</p>


<h3>Usage</h3>

<pre>
df2scidb(X, name = tmpnam(), dimlabel = "row", chunkSize,
         rowOverlap = 0L, types = NULL, nullable, schema_only = FALSE, gc, start)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>A data frame. </p>
</td></tr>
<tr valign="top"><td><code>name</code></td>
<td>
<p>The SciDB array name, defaults to an automatically-generated name.</p>
</td></tr>
<tr valign="top"><td><code>dimlabel</code></td>
<td>
<p>Name the SciDB dimension.</p>
</td></tr>
<tr valign="top"><td><code>chunkSize</code></td>
<td>
<p>The SciDB chunk size.</p>
</td></tr>
<tr valign="top"><td><code>rowOverlap</code></td>
<td>
<p>The SciDB chunk overlap.</p>
</td></tr>
<tr valign="top"><td><code>types</code></td>
<td>
<p>An optional vector explicitly specifying the SciDB attribute types. Length must match the number of columns of the data frame.</p>
</td></tr>
<tr valign="top"><td><code>nullable</code></td>
<td>
<p>An optional vector indicating the SciDB nullable property of each attribute. Length must match the number of columns of the data frame.</p>
</td></tr>
<tr valign="top"><td><code>schema_only</code></td>
<td>
<p>If TRUE, return a string that would represent the SciDB array schema without uploading data to SciDB.</p>
</td></tr>
<tr valign="top"><td><code>gc</code></td>
<td>
<p>Optional logical value. If TRUE, then resulting SciDB array will be garbage-collected when the R variable referencing it is. The default value is FALSE.</p>
</td></tr>
<tr valign="top"><td><code>start</code></td>
<td>
<p>Optional integer starting index value. Defaults to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>df2scidb</code> is a workhorse utility function that transfers an R data frame
into a 1-D SciDB array via intermediate CSV formatting.
The columns of the data frame correspond to attributes in the SciDB array. 
The <code>iquery</code> function returns query results using a similar method as R
data frames.
</p>


<h3>Value</h3>

<p>NULL is invisibly returned. SciDB errors are propagated as R error conditions.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
df2scidb(iris)
scidblist()
head(iquery("scan(iris)", return=TRUE))

## End(Not run)
</pre>


<table width="100%" summary="page for diff.scidb"><tr><td>diff.scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
diff
</h2>

<h3>Description</h3>

<p>Apply a finite difference operator to a numeric series.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'scidb'
diff(x,lag=1,...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code> object with a numeric attribute.</p>
</td></tr>
<tr valign="top"><td><code>lag</code></td>
<td>
<p>An intereger lag value (see description).</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Optional arguments, not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'x' is a vector of length 'n' and starting index 1, then the
computed result is equal to the difference
'x[(1+lag):n] - x[1:(n-lag)]'.
</p>
<p>If 'x' is a matrix then the difference operations are carried out
on each column separately.
</p>
<p>SciDB missing (NULL) and NaN values propagate.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for dimension_rename"><tr><td>dimension_rename</td><td align="right">R Documentation</td></tr></table>

<h2>
Rename a dimension.
</h2>

<h3>Description</h3>

<p>Rename a SciDB array dimension.
</p>


<h3>Usage</h3>

<pre>
dimension_rename(x, old, `new`, `eval`=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code>  or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>old</code></td>
<td>
<p>A character string representation of the old dimension name.</p>
</td></tr>
<tr valign="top"><td><code>new</code></td>
<td>
<p>A character string representation of the new dimension name.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>scidb</code> or <code>scidbdf</code> object.
</p>


<h3>Note</h3>

<p>If you don't specify the <code>old</code> argument, it defaults to the dimension
names of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
<code>attribute_rename</code>
<code>cast</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- as.scidb(iris)
y &lt;- dimension_rename(x, "row", "i")

str(y)

## End(Not run)</pre>


<table width="100%" summary="page for dimensions"><tr><td>dimensions</td><td align="right">R Documentation</td></tr></table>

<h2>
dimensions
</h2>

<h3>Description</h3>

<p>Return a vector of SciDB array dimension names.
</p>


<h3>Usage</h3>

<pre>
dimensions(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>An object of class <code>scidb</code> or <code>scidbdf</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of SciDB array dimension names.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Upload data to create a 10x10 SciDB matrix
A &lt;- as.scidb(matrix(rnorm(100),10))
dimensions(A)

## End(Not run)</pre>


<table width="100%" summary="page for dimnames.scidb"><tr><td>dimnames.scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
dimnames
</h2>

<h3>Description</h3>

<p>Return a list of dimension label arrays.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'scidb'
dimnames(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p> SciDB array reference object.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The scidb package can label SciDB array coordinate systems with
indices from other SciDB arays.
</p>


<h3>Value</h3>

<p>A list of dimension label arrays.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>dimnames&lt;-, rownames, colnames</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
A &lt;- as.scidb(matrix(rnorm(20),nrow=5))
colnames(A) &lt;- as.scidb(data.frame(letters[1:4]))
dimnames(A)

## End(Not run)</pre>


<table width="100%" summary="page for dim.scidb"><tr><td>dim.scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
dim
</h2>

<h3>Description</h3>

<p>dim
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'scidb'
dim(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of matrix dimensions or NULL.</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for dist"><tr><td>dist</td><td align="right">R Documentation</td></tr></table>

<h2>Distance Matrix Computation</h2>

<h3>Description</h3>

<p>Compute and return a distance matrix that contains the Euclidean
distance between rows of a data matrix.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
dist(x, method=c("euclidean","manhattan","maximum"))
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>a numeric matrix object of class <code>scidbdf</code>.</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p>the distance measure to be used. This must be one of
<code>euclidean</code>, <code>maximum</code>, or <code>manhattan</code>.
Any unambiguous substring can be given.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>(i,j)</code> position of
the output matrix contains the distance between rows
<code>i</code> and <code>j</code> of the data matrix <code>x</code> as measured
by the specified norm. The function only returns values below
the diagonal as a sparse SciDB matrix.
</p>
<p>Missing values are not allowed.
</p>


<h3>Value</h3>

<p><code>dist</code> returns a distance matrix object of class <code>"scidb"</code>.
</p>


<h3>See Also</h3>

<p><code>hclust</code>.
<code>dist</code>.
</p>


<table width="100%" summary="page for factor_scidb"><tr><td>factor_scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
Hybrid R/SciDB factors
</h2>

<h3>Description</h3>

<p>Create R factor variables that include SciDB dimension array index values.
</p>


<h3>Usage</h3>

<pre>
factor_scidb(x, levels)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>

<p>An R vector or factor vector.
</p>
</td></tr>
<tr valign="top"><td><code>levels</code></td>
<td>

<p>A SciDB dimension array. This can be an array created with the SciDB
<code>index_lookup</code> function, or any one-dimensional SciDB array. If the
array has more than one SciDB attribute, the first attribute will be used
to look up values from <code>x</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor vector with extra class <code>scidb_factor</code>, and two additional
attributes: <code>scidb_levels</code> contains an R vector of looked-up SciDB index
values from the <code>levels</code> array, and <code>scidb_index</code> contains a
reference to the <code>levels</code> array.
</p>


<h3>Note</h3>

<p><code>scidb_factor</code> values are treated specially when uploaded
from R to SciDB. Normal R factor values upload their contents. But <code>scidb_factor</code>
values upload their index values corresponding to their SciDB dimension array (as
type int64). Those values can then be directly joined with the SciDB dimension 
array, or any SciDB array using the same dimension index. See the examples below.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Consider a SciDB dimension array of Iris flower species, perhaps with
# some additional data (made up in this example).
set.seed(1)
species &lt;- data.frame(
  species=c("albicans","flavescens","germanica","setosa", "variegata", "versicolor", "virginica"),
  additional_data = runif(7))

species &lt;- as.scidb(species, dimlabel="index")
str(species)

# Fisher's iris data example contain a subset of these species.
str(iris$Species)

# Let's index the iris data with the SciDB array.
iris$Species &lt;- factor_scidb(iris$Species, species)

# The Species variable in the data frame now contains *two* indices, the usual
# R enumeration of levels, and a new set of levels corresponding to the SciDB
# lookup array. It also contains a reference to the lookup array.

# Let's upload the newly indexed iris data to SciDB. Observe that the 'Species'
# values are uploaded as SciDB int64 index values! Those indices are join-able
# with the dimension array used to create the factor.
x &lt;- as.scidb(iris)
str(x)

# The advantage is that the x$Species values can be joined or redimensioned
# conformably with the SciDB indexing array.

# The next example computes the average iris data values grouped by Species
# using SciDB's redimension function:
xr &lt;- redimension(x, dim="Species", FUN=mean)

# That output is join-able with the SciDB dimension array species:
merge(xr,species, by.x="Species", by.y="index")[]

# ...the output should look something like this...
#  Sepal_Length Sepal_Width Petal_Length Petal_Width    species additional_data
#4        5.006       3.428        1.462       0.246     setosa       0.9082078
#6        5.936       2.770        4.260       1.326 versicolor       0.8983897
#7        6.588       2.974        5.552       2.026  virginica       0.9446753


## End(Not run)</pre>


<table width="100%" summary="page for glm.fit"><tr><td>glm.fit</td><td align="right">R Documentation</td></tr></table>

<h2>
Fitting generalized linear models
</h2>

<h3>Description</h3>

<p><code>glm.fit</code> is used to fit generalized linear models specified by a model
matrix and response vector. <code>glm</code> is a simplified interface for
<code>scidbdf</code> objects similar (but much simpler than) <code>glm</code>.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
glm.fit(x,y,weights=NULL,family=gaussian())
## S4 method for signature 'ANY,ANY,scidbdf'
glm(formula, family=gaussian(), data, weights)
model_scidb(formula, data, factors=NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>a model matrix of dimension 'n * p'.</p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p>a response vector of length 'n'.</p>
</td></tr>
<tr valign="top"><td><code>formula</code></td>
<td>
<p>an object of class <code>formula</code> (or one that can be coerced to
that class): a symbolic description of the model to be
fitted. See details for limitations.</p>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
<p>an object of class <code>scidbdf</code>.</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the
fitting process.  Should be 'NULL' or a numeric or scidb vector.</p>
</td></tr>
<tr valign="top"><td><code>family</code></td>
<td>
<p>a description of the error distribution and link function to
be used in the model, supplied as the result of a call to
a family function.</p>
</td></tr>
<tr valign="top"><td><code>factors</code></td>
<td>
<p>a list of factor encodings to use in the model matrix. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>glm</code> function works similarly to a limited version of
the usual <code>glm</code> function, but with a <code>scidbdf</code> data.frame-like
SciDB array instead of a standard data.frame.
</p>
<p>Formulas in the <code>glm</code> function may only refer to variables explicitly
defined in the <code>data</code> <code>scidbdf</code> object.  That means that you should
bind interaction and transformed terms to your data before invoking the
function.  The indicated response must refer to a single-column response term
in the data (the two-column response form is not accepted).
</p>
<p>Categorical (factor) variables in the data must be represented as strings. They
will be encoded as treatment-style contrast variables with the first listed
value set to the baseline value. No other automated contrast encodings are
available yet (you are free to build your own model matrix and use
<code>glm.fit</code> for that). All other variables will be coerced to
double-precision values.
</p>
<p>Use the <code>model_scidb</code> function to build a model matrix from a formula and
a <code>scidbdf</code> data frame-like SciDB array.  The matrix is returned within an
output list as a sparse SciDB matrix of class <code>scidb</code> with character
string variables encoded as treatment contrasts as described above.
If you already have a list of factor-level codes for categorical variables
(for example from the output of <code>glm</code>, you can supply that in the
factor argument. See help for <code>predict</code> for an example.
</p>


<h3>Value</h3>

<p>The <code>glm.fit</code> and <code>glm</code> functions return
a list of model output values described below. The <code>glm</code>
method uses an S3 class to implement printing
<code>summary</code>, and <code>predict</code> methods.
</p>

<ol>
<li><p><EM>coefficients</EM>  model coefficient vector (SciDB array)
</p>
</li>
<li><p><EM>stderr</EM>  vector of model coefficient standard errors (SciDB array)
</p>
</li>
<li><p><EM>tval</EM>  vector of model coefficient t ratio values using estimated dispersion value (SciDB array)
</p>
</li>
<li><p><EM>pval</EM>  vector of two-tailed p-values corresponding to the t ratio based on a Student t distribution. (It is possible that the dispersion is not known and there are no residual degrees of freedom from which to estimate it.  In that case the estimate is 'NaN'.)
</p>
</li>
<li><p><EM>aic</EM>  a version of Akaike's <EM>An Information Criterion</EM> value.
</p>
</li>
<li><p><EM>null.deviance</EM>  the deviance for the null model, comparable with <code>deviance</code>.
</p>
</li>
<li><p><EM>res.deviance</EM>  up to a constant, minus twice the maximized log-likelihood.
</p>
</li>
<li><p><EM>dispersion</EM>  For binomial and Poison families the dispersion is
fixed at one and the number of parameters is the number of
coefficients. For gaussian, Gamma and inverse gaussian families the
dispersion is estimated from the residual deviance, and the number
of parameters is the number of coefficients plus one.  For a
gaussian family the MLE of the dispersion is used so this is a valid
value of AIC, but for Gamma and inverse gaussian families it is not. Other
families set this value to <code>NA</code>.
</p>
</li>
<li><p><EM>df.null</EM>  the residual degrees of freedom for the null model.
</p>
</li>
<li><p><EM>df.residual</EM>  the residual degrees of freedom.
</p>
</li>
<li><p><EM>converged</EM>  <code>FALSE</code> if the model did not converge.
</p>
</li>
<li><p><EM>totalObs</EM>  total number of observations in the model.
</p>
</li>
<li><p><EM>nOK</EM>  total number of observations corresponding to nonzero weights.
</p>
</li>
<li><p><EM>loglik</EM>  converged model log-likelihood value.
</p>
</li>
<li><p><EM>rss</EM>  residual sum of squares.
</p>
</li>
<li><p><EM>iter</EM>  number of model iterations.
</p>
</li>
<li><p><EM>weights</EM>  vector of weights used in the model (SciDB array).
</p>
</li>
<li><p><EM>family</EM>  model family function.
</p>
</li>
<li><p><EM>y</EM>  response vector (SciDB array).
</p>
</li>
<li><p><EM>x</EM>  model matrix (SciDB array).
</p>
</li>
<li><p><EM>factors</EM>  a list of factor variable levels (SciDB arrays)
or NULL if no factors are present in the data.
</p>
</li></ol>

<p><code>model_scidb</code>  returns an output list with:
</p>

<ul>
<li><p><EM>formula</EM>  the model forumual.
</p>
</li>
<li><p><EM>model</EM>  the model matrix (SciDB array).
</p>
</li>
<li><p><EM>response</EM>  the model response vector (SciDB array).
</p>
</li>
<li><p><EM>names</EM>  an R character vector of variable names in the model matrix.
</p>
</li>
<li><p><EM>intercept</EM>  a logical value; if TRUE the model includes an intercept term.
</p>
</li>
<li><p><EM>factors</EM>  a list of factor variable levels (SciDB arrays)
or NULL if no factors are present in the data.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
<code>predict</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Using glm.fit
x &lt;- as.scidb(matrix(rnorm(5000*20),nrow=5000))
y &lt;- as.scidb(rnorm(5000))
M &lt;- glm.fit(x, y)
coef(M)[]

# Using glm (similar to standard glm in this case)
# From the 'glm' help:
## Dobson (1990) Page 93: Randomized Controlled Trial :
counts &lt;- c(18,17,15,20,10,20,25,13,12)
outcome &lt;- gl(3,1,9)
treatment &lt;- gl(3,3)
d.AD &lt;- data.frame(treatment, outcome, counts)
glm.D93 &lt;- glm(counts ~ outcome + treatment, family = poisson(),data=d.AD)
summary(glm.D93)

# Compare with:
d.AD_sci = as.scidb(d.AD)
glm.D93_sci = glm(counts ~ outcome + treatment, family = poisson(), data=d.AD_sci)
summary(glm.D93_sci)

## End(Not run)</pre>


<table width="100%" summary="page for grand-methods"><tr><td>grand-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Miscellaneous methods from package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p>The methods described here compute a global aggregate on a
SciDB array object and return a scalar value to R.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
mean(x)
## S4 method for signature 'scidb'
mean(x)
## S4 method for signature 'scidb'
median(x)
## S4 method for signature 'scidbdf'
median(x)
## S4 method for signature 'scidbdf'
sum(x)
## S4 method for signature 'scidbdf'
sum(x)
## S4 method for signature 'scidb'
min(x)
## S4 method for signature 'scidbdf'
min(x)
## S4 method for signature 'scidb'
max(x)
## S4 method for signature 'scidbdf'
max(x)
## S4 method for signature 'scidb'
count(x)
## S4 method for signature 'scidbdf'
count(x)
## S4 method for signature 'scidb'
sd(x)
## S4 method for signature 'scidbdf'
sd(x)
## S4 method for signature 'scidb'
var(x)
## S4 method for signature 'scidbdf'
var(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code> or <code>scidbdf</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sum</code> computes the global sum of the SciDB array elements (applies only to numeric types);
<code>mean</code> computes the arithmetic average of the SciDB array elements;
<code>median</code> computes the median of the SciDB array elements;
<code>min</code> computes the minimum of the SciDB array elements;
<code>max</code> computes the maximum of the SciDB array elements;
<code>count</code> returns the number of non-empty cell values in the SciDB array;
<code>sd</code> computes the standard deviation of the SciDB array elements (numeric only);
<code>var</code> computes the variance of the SciDB array elements (numeric only).
</p>


<h3>Value</h3>

<p>The methods documented here always return a scalar value.</p>


<h3>Note</h3>

<p>SciDB convention dictates that global aggregates only apply to the first
listed attribute of a multi-attribute SciDB array (e.g., a scidbdf data
frame-like object). Use <code>project(array, attribute)</code> to select a
different attribute&ndash;see the examples.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
data("iris")
x &lt;- as.scidb(iris)
sum(x$Petal_Length)

## End(Not run)
</pre>


<table width="100%" summary="page for hist-methods"><tr><td>hist-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Methods for Function <code>hist</code> in Package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p>The generic function 'hist' computes a histogram of the given data
values.  If 'plot = TRUE', the resulting object of class
<code>histogram</code> is plotted by <code>plot.histogram</code>, before it is
returned.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
hist(x, breaks=10, right=FALSE, materialize=TRUE, `eval`=FALSE, `plot`=TRUE, ...)
## S4 method for signature 'scidbdf'
hist(x, breaks=10, right=FALSE, materialize=TRUE, `eval`=FALSE, `plot`=TRUE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code> or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>breaks</code></td>
<td>
<p>a single number giving the number of cells for the histogram.</p>
</td></tr>
<tr valign="top"><td><code>right</code></td>
<td>
<p>logical; if <code>TRUE</code>, the histogram cells are right-closed (left open) intervals.</p>
</td></tr>
<tr valign="top"><td><code>materialize</code></td>
<td>
<p>logical; if <code>TRUE</code>, the histogram results are materialized into R vectors and returned as a standard object of class <code>histogram</code>. Otherwise the results are returned as SciDB objects.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>Optional, logical; If <code>TRUE</code>, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
<tr valign="top"><td><code>plot</code></td>
<td>
<p>Optional, logical; If <code>TRUE</code>, plot result before returning.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Optional; additional arguments for plotting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This histogram function only supports equidistant breaks. If 'right = TRUE'
(default), the histogram cells are intervals of the form '(a, b]', i.e., they
include their right-hand endpoint, but not their left one.
</p>


<h3>Value</h3>

<p>A <code>histogram</code> object, which is a list of components:
</p>

<ul>
<li><p> breaks: the n+1 cell boundaries.
</p>
</li>
<li><p> counts: n integers; for each cell, the number of <code>x[]</code> inside.
</p>
</li>
<li><p> density: estimated density values.
</p>
</li>
<li><p> mids: the n cell midpoints.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for hypergeometric-methods"><tr><td>hypergeometric-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Hypergeometric functions in Package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p>Distribution and quantile functions 
for the hypergeometric distribution.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb_or_scidbdf'
phyper(x, q, m, n, k, new="p",`eval`=FALSE)
## S4 method for signature 'scidb_or_scidbdf'
qhyper(x, p, m, n, k, new="q",`eval`=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code> or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>q</code></td>
<td>
<p>A SciDB attribute name (character) or numeric constant representing the 
quantile, for example the number of white balls drawn without replacement
from an urn which contains both black and white balls.</p>
</td></tr>
<tr valign="top"><td><code>m</code></td>
<td>
<p>A scidb attribute name or numeric constant representing
the number of white balls in the urn.</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p>A scidb attribute name or numeric constant representing
the number of black balls in the urn.</p>
</td></tr>
<tr valign="top"><td><code>k</code></td>
<td>
<p>A scidb attribute name or numeric constant representing
the number of balls drawn from the urn.</p>
</td></tr>
<tr valign="top"><td><code>p</code></td>
<td>
<p>A scidb attribute name or numeric constant representing
probability between 0 and 1.</p>
</td></tr>
<tr valign="top"><td><code>new</code></td>
<td>
<p>A character name for the result attribute.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hypergeometric distribution is used for sampling <EM>without</EM>
replacement.  The density of this distribution with parameters
<code>m</code>, <code>n</code> and <code>k</code> is given by
</p>
<p align="center"><i>p(x) =      choose(m, x) choose(n, k-x) / choose(m+n, k)</i></p>

<p>for <i>x = 0, &hellip;, k</i>.
</p>
<p>The quantile is defined as the smallest value <i>x</i> such that
<i>F(x) &ge; p</i>, where <i>F</i> is the distribution function.
</p>
<p><code>phyper</code> gives the distribution
function, <code>qhyper</code> gives the quantile function.
</p>


<h3>Value</h3>

<p>A <code>scidb</code>, <code>scidbdf</code> reference object. </p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Write me

## End(Not run)
</pre>


<table width="100%" summary="page for index_lookup"><tr><td>index_lookup</td><td align="right">R Documentation</td></tr></table>

<h2>
index_lookup
</h2>

<h3>Description</h3>

<p>The <code>index_lookup</code> function is a wrapper to the SciDB 'index_lookup' operator.
It produces a new SciDB dimension array that joins the unqiue indices defined in the array
<code>I</code> with values looked up in array <code>X</code> for attribute <code>attr</code>. Use
the <code>index_lookup</code> with the <code>unique</code> and <code>sort</code> functions.
</p>


<h3>Usage</h3>

<pre>
index_lookup(X, I, attr, new_attr, eval=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>A scidb or scidbdf object</p>
</td></tr>
<tr valign="top"><td><code>I</code></td>
<td>
<p>A scidb or scidbdf object</p>
</td></tr>
<tr valign="top"><td><code>attr</code></td>
<td>
<p>A character string attribute name from the <code>X</code> array</p>
</td></tr>
<tr valign="top"><td><code>new_attr</code></td>
<td>
<p>An optional character name for the new attribute, defaults to <code>attr</code> + &quot;_index&quot;</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>scidb</code>  or <code>scidbdf</code> object.
</p>


<h3>Note</h3>

<p>If <code>attr</code> is missing, the first SciDB attribute of <code>X</code> will be used.
If <code>I</code> has more than one attribute, then its first attribute will be used.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
data("iris")
x &lt;- as.scidb(iris)

# Create a unique list of elements of the "Species" attribute.
# Note that we choose to defer evaluation of this expression.
y &lt;- unique(sort(project(x,"Species")), eval=FALSE)

# Append a new attribute to the array x called "Species_index" that
# enumerates the unique values of the "Species" attribute:
z &lt;- index_lookup(x, y, "Species", eval=FALSE)

print(head(z))

## End(Not run)</pre>


<table width="100%" summary="page for iquery"><tr><td>iquery</td><td align="right">R Documentation</td></tr></table>

<h2>Simple SciDB query tool</h2>

<h3>Description</h3>

<p>Issue SciDB queries and optionally return output in a data frame.</p>


<h3>Usage</h3>

<pre>
iquery(query, `return` = FALSE, afl = TRUE,
       iterative = FALSE, n = 10000, excludecol,
       binary = FALSE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>query</code></td>
<td>
<p>A SciDB query string (character). Separate multiple queries
with semicolons. </p>
</td></tr>
<tr valign="top"><td><code>return</code></td>
<td>
<p>Set to TRUE to return output. Otherwise don't return
query output. Only available when <code>afl=TRUE</code></p>
</td></tr>
<tr valign="top"><td><code>afl</code></td>
<td>
<p>TRUE indicates query is in AFL form, FALSE indicates AQL. </p>
</td></tr>
<tr valign="top"><td><code>iterative</code></td>
<td>
<p>Set to TRUE to return a result iterator. FALSE returns
entire result at once.</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p>Maximum number of rows to return when iterating through results.
Set to <code>Inf</code> to return everything. Ignored when binary=TRUE.</p>
</td></tr>
<tr valign="top"><td><code>excludecol</code></td>
<td>
<p>An optional numeric range of columns to exclude from
iterative results (only applies when iterative=TRIE).</p>
</td></tr>
<tr valign="top"><td><code>binary</code></td>
<td>
<p>TRUE indicates efficient binary transfer method. Set to
FALSE to use read.table and UTF8 encoded text transfer, parsed
by <code>read.table</code> (more flexible parsing for unusual types).</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Options passed on to <code>read.table</code> used to parse results when
<code>binary=FALSE</code>.  See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>iquery</code> function is an analog of the command-line SciDB <code>iquery</code>
program. Use it to issue arbitrary SciDB queries.
</p>
<p>Several return options are available. Select <code>binary=TRUE</code> to bring the
entire result of the query to R using an efficient binary transfer.  Note that
for now, selecting <code>binary=TRUE</code> implies <code>n=Inf</code>&ndash;that is, the whole
result comes back at once.
</p>
<p>When <code>binary=TRUE</code> is selected, two optional arguments become available:
</p>

<ul>
<li> <p><code>buffer=100000</code>:  The binary returned data will be parsed in chunks of
at most <code>buffer</code> rows. Adjust this for performance.
</p>
</li>
<li> <p><code>row.names=NULL</code>: Similarly to R's <code>read.table</code> function, set
this value to be a vector of row labels for the output, or optionally a single
number indicating the output column to use as row names for the output
data.frame.
</p>
</li>
<li> <p><code>unpack=TRUE</code>: Set <code>unpack</code> to FALSE to return only the array
attribute data values. The default <code>unpack=TRUE</code> returns coordinate indices
and the array attribute values.
</p>
</li></ul>

<p>Select <code>binary=FALSE</code> to use a delimited text transfer option. Data are
transferred using delimited text and parsed through R's <code>read.table</code>
function. When this option is selected, any <code>...</code> arguments are passed
directly to <code>read.table</code>. You can limit the number of returned results
to <code>n</code> when this option is set.
</p>
<p>Select <code>iterative=TRUE</code> to return an iterator that iterators over <code>n</code>
output rows at a time. This option only supports delimted text transfers.
</p>


<h3>Value</h3>

<p>If <code>return=TRUE</code>, return the query result in data frame form (similar to the
SciDB <code>iquery</code> command-line <code>-olcsv+</code> output option).
</p>
<p>If <code>return</code>=FALSE, return the query ID number.
</p>
<p>SciDB errors encountered during query processing are propagated to R and can
be handled with normal R error handling mechanisms.
</p>
<p>Set <code>itreative=TRUE</code> to return a result iterator. Use the iterator <code>nextElem</code>
function to iteratively return results, a maximum of <code>n</code> results at a time. See
help in the <code>iterators</code> package for examples and options.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
iquery("list('instances')",return=TRUE)

# A simple example that iterates through results using foreach
# Build an array with 1 million numbers from zero to 1.
iquery("store(build(&lt;x:double&gt;[i=1:1000000,100000,0],i/1000000),X)")
# Apply a function and return result in an iterator:
i &lt;- iquery("apply(X, y, sin(x))", return=TRUE, iterative=TRUE)

# Sum up x and y (and dimension i too)
library("foreach")
foreach(j=i, .combine=function(...)colSums(rbind(...))) 

# Compare with the much faster equivalent inside SciDB:
iquery("aggregate(apply(X, y, sin(x)),sum(x),sum(y))", return=TRUE)


## End(Not run)</pre>


<table width="100%" summary="page for is.scidbdf"><tr><td>is.scidbdf</td><td align="right">R Documentation</td></tr></table>

<h2>
is.scidbdf
</h2>

<h3>Description</h3>

<p>Is this a SciDB array data.frame-like object?
</p>


<h3>Usage</h3>

<pre>
is.scidbdf(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>Something.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if <code>x</code> is a SciDB object.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for is.scidb"><tr><td>is.scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
is.scidb
</h2>

<h3>Description</h3>

<p>Is this a SciDB array object?
</p>


<h3>Usage</h3>

<pre>
is.scidb(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>Something.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if <code>x</code> is a SciDB object.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for is.temp"><tr><td>is.temp</td><td align="right">R Documentation</td></tr></table>

<h2>
is.temp
</h2>

<h3>Description</h3>

<p>Is <code>name</code> a temporary SciDB array?
</p>


<h3>Usage</h3>

<pre>
is.temp(name)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>name</code></td>
<td>
<p>Either a <code>scidb</code> or <code>scidbdf</code> object, or a character
string representing a stored SciDB array name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if <code>x</code> is a temporary SciDB array.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for kmeans"><tr><td>kmeans</td><td align="right">R Documentation</td></tr></table>

<h2>
kmeans
</h2>

<h3>Description</h3>

<p>Basic kmeans clustering using Lloyd's algorithm
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
kmeans(x,  centers, iter.max=30, nstart=1,
  algorithm="Lloyd")
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A scidb object representing a matrix.</p>
</td></tr>
<tr valign="top"><td><code>centers</code></td>
<td>
<p>the number of clusters</p>
</td></tr>
<tr valign="top"><td><code>iter.max</code></td>
<td>
<p>the maximum number of iterations allowed</p>
</td></tr>
<tr valign="top"><td><code>nstart</code></td>
<td>
<p>Not (yet) used by this implementation</p>
</td></tr>
<tr valign="top"><td><code>algorithm</code></td>
<td>
<p>Not (yet) used by this implementation (always Lloyd's)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>kmeans</code>.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>kmeans</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Let's generate data with obvious clusters.
set.seed(1)
x &lt;- c(x=rnorm(50),rnorm(50)+3);y = c(rnorm(50),rnorm(50)+3)
A &lt;- cbind(x,y)
# Plot the data (try to set the aspect ratio square)
# Let a be an m x n matrix.
# Each row of the matrix A is a point in an n-dimensional Euclidean space.
library("scidb")
scidbconnect()
A = as.scidb(A)
k = kmeans(A, 2, 10)
plot(A[], asp=1,xlab="x",ylab="y")
points(A[k$cluster %==%0, ][], pch=19,col=4)

## End(Not run)</pre>


<table width="100%" summary="page for lag"><tr><td>lag</td><td align="right">R Documentation</td></tr></table>

<h2>
lag
</h2>

<h3>Description</h3>

<p>Lag or lead a time series
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
lag(x, k=1, dim=1, `eval`=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A scidb array object.</p>
</td></tr>
<tr valign="top"><td><code>k</code></td>
<td>
<p>Coordinate system units to lag by.</p>
</td></tr>
<tr valign="top"><td><code>dim</code></td>
<td>
<p>SciDB array dimension to lag along.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scidb array object with identical schema as <code>x</code>, but whose values are shifted along the coordinate axis <code>dim</code> by the lag value <code>k</code>.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- build("i",dim=10,names=c("x","i"),start=1,type="double")
y &lt;- lag(x)
merge(x,y,by="i",all=TRUE)

## End(Not run)</pre>


<table width="100%" summary="page for length.scidb"><tr><td>length.scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
length
</h2>

<h3>Description</h3>

<p>Return the total number of array elements of a SciDB array object.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'scidb'
length(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>

<p>A <code>scidb</code> object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric length of the object in elements.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for levels_scidb"><tr><td>levels_scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
Hybrid R/SciDB factors
</h2>

<h3>Description</h3>

<p>Return levels for this factor vector from a SciDB dimension array.
</p>


<h3>Usage</h3>

<pre>
levels_scidb(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>

<p>An R factor vector created by <code>factor_scidb</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The SciDB dimension array levels associated with the factors in this vector.
Those levels may differ from the enumeration used for the R factor levels
returned by <code>levels(x)</code>.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for merge-methods"><tr><td>merge-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Methods for Function <code>merge</code> in Package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p>SciDB <code>merge</code>, <code>cross_join</code>, and <code>join</code> operations.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
merge(x,y, by=intersect(dimensions(x),dimensions(y)), by.x, by.y, merge, all)
## S4 method for signature 'scidbdf'
merge(x,y, by=intersect(dimensions(x),dimensions(y)), by.x, by.y, merge, all)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code> or <code>scidbdf</code></p>
</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
<p>A <code>scidb</code> or <code>scidbdf</code></p>
</td></tr>
<tr valign="top"><td><code>by</code></td>
<td>
<p>(Optional) Vector of common dimension or attribute names or dimension indices
to join on. See details below.</p>
</td></tr>
<tr valign="top"><td><code>by.x</code></td>
<td>
<p>(Optional) Vector of dimension or attribute names or dimension indices
of array <code>x</code> to join on. See deails.</p>
</td></tr>
<tr valign="top"><td><code>by.y</code></td>
<td>
<p>(Optional) Vector of dimension or attribute names or dimension indices
of array <code>y</code> to join on. See deails.</p>
</td></tr>
<tr valign="top"><td><code>merge</code></td>
<td>
<p>(Optional) If TRUE, perform a SciDB merge operation instead
of join.</p>
</td></tr>
<tr valign="top"><td><code>all</code></td>
<td>
<p>(Optional) If TRUE, perform outer join. Defaults to inner join.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only one of either <code>by</code> or both <code>by.x</code> and <code>by.y</code> may be
specified.  If none of the <code>by.x</code>,<code>by.y</code> arguments are specified, and
<code>by=NULL</code> the result is the Cartesian cross product of <code>x</code> and
<code>y</code>.  The default value of <code>by</code> performs a <code>cross_join</code> or
<code>join</code> along common array dimensions. The <code>by</code> arguments may
be specified by name or 1-based integer dimension index.
</p>
<p>If only <code>by</code> is specified, the dimension names or attribute name in
<code>by</code> are assumed to be common across <code>x</code> and <code>y</code>.  Otherwise
dimension names or attribute names are matched across the names listed in
<code>by.x</code> and <code>by.y</code>, respectively.
</p>
<p>If dimension names are specified and <code>by</code> contains all the dimensions
in each array, then the SciDB <code>join</code> operator is used, otherwise SciDB's
<code>cross_join</code> operator is used. In each either case, the output is a cross
product set of the two arrays along the specified dimensions.
</p>
<p>If <code>by</code> or each of <code>by.x</code> and <code>by.y</code> list a single attribute
name, the indicated attributes will be lexicographically ordered as categorical
variables and SciDB will redimension each array along new coordinate systems
defined by the attributes, and then those redimensioned arrays will be joined.
This method limits joins along attributes to a single attribute from
each array. The output array will contain additional columns showing the
attribute factor levels used to join the arrays.
</p>
<p>Specify <code>merge=TRUE</code> to perform a SciDB merge operation instead
of a SciDB join.
</p>
<p>If <code>all=FALSE</code> (the default), then a SQL-like 'natural join' 
(an inner join) is performed. If <code>all=TRUE</code> then SQL-like 'outer join'
is performed, but this case has some limitiations; in particular the
outer join is not available yet for the <code>merge=TRUE</code> case, for
joining on SciDB attributes, or for joining on subsets of dimensions.
</p>
<p>The various SciDB <code>join</code> operators generally require that the arrays have
identical partitioning (coordinate system bounds, chunk size, etc.) in the
common dimensions.  The <code>merge</code> method attempts to rectify SciDB
arrays along the specified dimensions as required before joining. Those
dimensions must at least have common lower index bounds.
</p>
<p>The merge function may rename SciDB attributes and dimensions as required
to avoid name conflicts in SciDB. See the last example for an
illustration.
</p>


<h3>Value</h3>

<p>A <code>scidb</code> or <code>scidbdf</code> reference object. </p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Create a copy of the iris data frame in a 1-d SciDB array named "iris."
# Note that SciDB attribute names will be changed to conform to SciDB
# naming convention.
x &lt;- as.scidb(iris,name="iris")

a &lt;- x$Species
b &lt;- x$Petal_Length

c &lt;- merge(a, b, by="row")
merge(b, b, by="row", merge=TRUE)


# Here is an example that joins on SciDB array attributes instead of
# dimensions. It works by enumerating the attribute values and
# redimensioning along those.
set.seed(1)
a &lt;- as.scidb(data.frame(a=sample(10,5),b=rnorm(5)))
b &lt;- as.scidb(data.frame(u=sample(10,5),v=rnorm(5)))
merge(x=a, y=b, by.x="a", by.y="u")[]


# The following example joins on a subset of coordinate axes:
x &lt;- build(5.5, c(3,3));                  print(schema(x))
y &lt;- build(1.1, c(3,3),chunksize=c(2,1)); print(schema(y))
z &lt;- merge(x, y, by="i")
print(schema(z))


## End(Not run)
</pre>


<table width="100%" summary="page for na.locf-methods"><tr><td>na.locf-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Methods for Function <code>na.locf</code> in Package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p>Generic function for replacing each missing or empty value with the most recent
non-missing value prior to it.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
na.locf(object, along=dimensions(object)[1],fill_sparse=FALSE,`eval`=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
<p>A <code>scidb</code> or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>along</code></td>
<td>
<p>A single SciDB array dimension name to replace missing values along.</p>
</td></tr>
<tr valign="top"><td><code>fill_sparse</code></td>
<td>
<p>Specify TRUE to impute sparse values, leave as the default FALSE
to only impute missing (SciDB NULL) values.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the usual <code>na.locf</code> function from the <code>zoo</code> package, the SciDB
<code>na.locf</code> function fills in both missing (SciDB <code>null</code> values) and
empty (SciDB sparse) values with the last non-missing and non-sparse value
along the indicated dimension.
</p>
<p>Time series represented in SciDB are often sparse arrays. The <code>na.locf</code>
function defines a conveniet way to  fill in all missing values along the time
coordinate axis down to the time resolution.
</p>
<p>Caution! If fill_sparse=TRUE then
the output array is a mostly dense, filled-in version of the input
array. If the time resolution is very fine and the input array very sparse,
then the output array can be huge. Consider using <code>regrid</code> first on
very fine time scales to reduce their resolution.
</p>


<h3>Value</h3>

<p>A <code>scidb</code> reference object. </p>


<h3>Note</h3>

<p>The default <code>na.locf</code> method in the <code>zoo</code> package unforunately
overrides this function (it uses <code>ANY</code> in its method signature). If
you need to use SciDB arrays and the <code>zoo</code> package, prefix SciDB's
version with <code>scidb::na.locf(...)</code>.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for names.scidb"><tr><td>names.scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
Dimension names
</h2>

<h3>Description</h3>

<p>Return 2nd dimension names of a SciDB array with two or more dimensions,
or just the single dimension names of a 1-d SciDB array reference object.
Warning! Huge SciDB arrays can retun too much. See 
<code>scidb</code> for an example alternative approach.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'scidb'
names(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p> A SciDB array reference object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of dimension names.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for nrow.scidb"><tr><td>nrow.scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
Number of rows or columns of a SciDB matrix.
</h2>

<h3>Description</h3>

<p>Return the number of rows of a SciDB matrix (2-D array).
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'scidb'
nrow(x)
## S3 method for class 'scidb'
ncol(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>

<p>A <code>scidb</code> object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of rows of the matrix.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for Ops.scidb"><tr><td>Ops.scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
Binary scidb object operations.
</h2>

<h3>Description</h3>

<p>Binary scidb object operations.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'scidb'
Ops(e1, e2)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>e1</code></td>
<td>

<p>A scalar, vector, or matrix value, or SciDB array reference.
</p>
</td></tr>
<tr valign="top"><td><code>e2</code></td>
<td>

<p>A scalar, vector, or matrix value, or SciDB array reference.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scidb or scidbdf object.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for order.scidb-methods"><tr><td>order.scidb-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Methods for Function <code>order</code> in Package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p><code>order</code>
returns a permutation which rearranges its first argument
into ascending or descending order, breaking ties by further
arguments. 
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
order.scidb(..., na.last = TRUE, decreasing = FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>...</code></td>
<td>
<p>A <code>scidb</code> vector object.</p>
</td></tr>
<tr valign="top"><td><code>decreasing</code></td>
<td>
<p>A logical value: TRUE means sort in decreasing order.</p>
</td></tr>
<tr valign="top"><td><code>na.last</code></td>
<td>
<p>NOT USED&ndash;for compatability with native R functions only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>scidb</code> reference object.</p>


<h3>Note</h3>

<p>Due to technical difficulties encountered when dispatching on <code>...</code>, the
<code>order.scidb</code> method must be called by its full name.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- scidb("build(&lt;v:double&gt;[i=1:10,10,0],random()

a &lt;- order.scidb(x)
print(a)

## End(Not run)
</pre>


<table width="100%" summary="page for peek"><tr><td>peek</td><td align="right">R Documentation</td></tr></table>

<h2>
Sample from populated cells in a SciDB array.
</h2>

<h3>Description</h3>

<p>Return an R dataframe containing samples from an input array.
</p>


<h3>Usage</h3>

<pre>
peek (x, n=50L, prob=1)
iqdf (x, n=50L, prob=1)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code>  or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p>Return at most <code>n</code> elements.</p>
</td></tr>
<tr valign="top"><td><code>prob</code></td>
<td>
<p>A number in the interval (0, 1] 
indicating the probability of a cell being included
in the sample.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Peek at non-empty values of an array, returning at most <code>n</code> values.
Use <code>peek</code> to get a sense of the data contained in an array.
</p>
<p>The function always returns results in data frame form, including
the array coordinates as data frame variables.
</p>


<h3>Value</h3>

<p>An R data frame.
</p>


<h3>Note</h3>

<p>The synonym <code>iqdf</code> is maintained for compatibility with existing programs.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>bernoulli</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- as.scidb(iris)
peek(x)

## End(Not run)</pre>


<table width="100%" summary="page for persist"><tr><td>persist</td><td align="right">R Documentation</td></tr></table>

<h2>
persist
</h2>

<h3>Description</h3>

<p>Mark a <code>scidb</code> or <code>scidbdf</code> object and any SciDB arrays in its
dependency graph persistent.
</p>


<h3>Usage</h3>

<pre>
persist(x, remove = FALSE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p> A scidb or scidbdf object</p>
</td></tr>
<tr valign="top"><td><code>remove</code></td>
<td>
<p> A logical value. See details.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p> Optional arguments not used by the default method, but reserved for future use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most <code>scidb</code> objects are ephemeral unless the <code>gc=FALSE</code> option is
explicitly selected. Use the <code>persist</code> function with <code>remove=FALSE</code>
to mark an array and all of its dependencies persistent. This is useful when
you want to save a <code>scidb</code> object to an R data file and make sure its data
is there when re-loaded.
</p>
<p>Specify <code>remove=TRUE</code> to 'unpersist' an object and all of its dependencies.
</p>


<h3>Value</h3>

<p>NULL is invisibly returned. Use this function for its side effects.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- as.scidb(iris)
y &lt;- unique(x$Species)
persist(y)
save(y, file="y.rdata")

# Now, *both* x and y can be removed without deleting the backing SciDB
# array. Without persist or setting gc=FALSE on x, the array would have
# been removed.
rm(x,y)
gc()

# Since the array is still there, we can get it back.
load("y.rdata")
y[]

## End(Not run)</pre>


<table width="100%" summary="page for predict"><tr><td>predict</td><td align="right">R Documentation</td></tr></table>

<h2>
Prediction for SciDB GLM fits
</h2>

<h3>Description</h3>

<p>Obtains predictions and optionally estimates standard errors of
those predictions from a fitted generalized linear model object.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'glm_scidb'
predict(object, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
<p> a <code>glm_scidb</code> model object.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p> optional arguments <code>newdata</code>, <code>type</code>, and <code>se.fit</code> (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Optional arguments:
</p>

<ul>
<li><p><code>newdata</code> a <code>scidbdf</code> SciDB data frame in which to look
for variables with which to predict.  If omitted, the fitted
linear predictors are used.
</p>
</li>
<li><p><code>type</code> the type of prediction required.  The default is on the scale
of the linear predictors; the alternative &quot;response&quot; is on
the scale of the response variable.  Thus for a default
binomial model the default predictions are of log-odds
(probabilities on logit scale) and <code>type = "response"</code> gives
the predicted probabilities.
</p>
</li>
<li><p><code>se.fit</code> logical switch indicating if standard errors are required.
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>se.fit = FALSE</code>, a vector of predictions.
</p>
<p>If <code>se.fit = TRUE</code>, a list with components
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>fit</code></td>
<td>
<p> Predictions, as for <code>se.fit = FALSE</code>.</p>
</td></tr>
<tr valign="top"><td><code>se.fit</code></td>
<td>
<p> Estimated standard errors.</p>
</td></tr>
<tr valign="top"><td><code>residual.scale</code></td>
<td>
<p> A scalar giving the square root of the dispersion used
in computing the standard errors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;, adapted from the R <code>predict.glm</code> documentation.
</p>


<h3>See Also</h3>

<p><code>scidb</code>
<code>glm</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
## example adpted from Venables and Ripley (2002, pp. 190-2.):

# In R:
ldose   &lt;- rep(0:5, 2)
numdead &lt;- c(1, 4, 9, 13, 18, 20, 0, 2, 6, 10, 12, 16)
sex     &lt;- factor(rep(c("M", "F"), c(6, 6)))
data    &lt;- data.frame(sex, ldose)
data    &lt;- Reduce(rbind, 
             lapply(1:length(numdead),
               function(j) rbind(cbind(alive=1,data[j,])[rep(1,numdead[j]),],
                                 cbind(alive=0,data[j,])[rep(1,20-numdead[j]),])))
rownames(data) &lt;- NULL

r_model &lt;- glm( alive ~ sex + ldose - 1, family=binomial(), data=data)

# Now in SciDB:
data_scidb &lt;- as.scidb(data)
str(data_scidb)
scidb_model &lt;- glm( alive ~ sex + ldose - 1, family=binomial(), data=data_scidb)

# New data for prediction:
ld &lt;- seq(0,5,0.1)
newdata &lt;- as.scidb(data.frame(ldose=ld, sex=rep("M",length(ld))))
head(newdata)

pred_scidb = predict(scidb_model, newdata=newdata, type="response")
head(pred_scidb)

require("graphics")
plot(c(1,32), c(0,1), type = "n", xlab = "dose",
          ylab = "prob", log = "x")
text(2^ldose, numdead/20, as.character(sex))
lines(2^ld, pred_scidb[],lwd=2,col=4)

## End(Not run)
</pre>


<table width="100%" summary="page for print.scidb"><tr><td>print.scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
Print a summary of a SciDB array object.
</h2>

<h3>Description</h3>

<p>Print a summary of a SciDB array object.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'scidb'
print(x, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p> A scidb array object.
</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Printed summary output.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradim4.com&gt;
</p>


<table width="100%" summary="page for project"><tr><td>project</td><td align="right">R Documentation</td></tr></table>

<h2>
project
</h2>

<h3>Description</h3>

<p>The <code>project</code> function is a wrapper to the SciDB 'project' operator.
It creates a new array that is a subset of the input array limited
to a set of specified attributes.
</p>


<h3>Usage</h3>

<pre>
project(X, attributes, eval)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>A scidb or scidbdf object</p>
</td></tr>
<tr valign="top"><td><code>attributes</code></td>
<td>
<p>A character vector of attributes to project on to</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>scidb</code> object.
</p>


<h3>Note</h3>

<p>Use <code>eval=FALSE</code> to defer expression evaluation for efficiency.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- as.scidb(iris)
y &lt;- project(x, c("Sepal_Length","Petal_Length","Species"))

print(head(y))

## End(Not run)</pre>


<table width="100%" summary="page for quantile"><tr><td>quantile</td><td align="right">R Documentation</td></tr></table>

<h2>
Sample Quantiles
</h2>

<h3>Description</h3>

<p>Compute sample quantiles of a single-attribute SciDB array.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'scidb'
quantile(x, probs=seq(0,1,0.25), type=7, ...)
## S3 method for class 'scidbdf'
quantile(x, probs=seq(0,1,0.25), type=7, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p> a <code>scidb</code> or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>probs</code></td>
<td>
<p> a numeric vector of probabilities with value in [0,1].</p>
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>
<p> either 1 or 7, selecting the two available quantile algorithms
(see help for <code>quantile</code> for more details).</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p> optional arguments that might be used in a future version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input array contains more than one attribute, the first
numeric attribute will be chosen (with a warning). Use <code>project</code> to
select a single attribute.
</p>
<p>The SciDB <code>quantile</code> function only supports types 1 and 7 at the time
of this writing. Quantile type 1 can be used with non-numeric values, as long
as they can be ordered. See <code>quantile</code> for much more detail on
the calculation.
</p>


<h3>Value</h3>

<p>A two-attribute SciDB data frame-like array with <code>length(probs)</code> rows is
returned.  The first attribute contains <code>probs</code> and the second attribute
the sample quantiles.
</p>


<h3>Author(s)</h3>

<p>A. Poliakov &lt;apoliakov@paradigm4&gt;
</p>


<h3>See Also</h3>

<p><code>quantile</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- as.scidb(rnorm(1000))
quantile(x)[]

quantile(x,type=1)[]

## End(Not run)
</pre>


<table width="100%" summary="page for rank-methods"><tr><td>rank-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Methods for Function <code>rank</code> in Package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p><code>rank</code>
Returns the sample ranks of the values in a vector.  Ties (i.e.,
equal values) and missing values can be handled in several ways.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
rank(x, na.last = TRUE,
          ties.method = c("average", "first", "random", "max", "min"))
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code> vector object.</p>
</td></tr>
<tr valign="top"><td><code>na.last</code></td>
<td>
<p>NOT USED&ndash;for compatability with native R functions only.</p>
</td></tr>
<tr valign="top"><td><code>ties.method</code></td>
<td>
<p>SciDB supports average or random.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>scidb</code> reference object.</p>


<h3>Note</h3>

<p>Select either <code>average</code> or <code>random</code> for <code>ties.method</code>.
If all components are different (and no 'NA's), the ranks are well
defined, with values in 'seq_len(x)'.  With some values equal
(called 'ties'), the argument 'ties.method' determines the result
at the corresponding indices.
The <code>random</code> method puts these in random order whereas the default,
<code>average</code>, replaces them by their mean.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- scidb("build(&lt;v:double&gt;[i=1:10,10,0],random()

a &lt;- order.scidb(x)
print(a)

## End(Not run)
</pre>


<table width="100%" summary="page for redimension"><tr><td>redimension</td><td align="right">R Documentation</td></tr></table>

<h2>
redimension
</h2>

<h3>Description</h3>

<p>The <code>redimension</code> function is a wrapper to the SciDB 'redimension' operator.
</p>


<h3>Usage</h3>

<pre>
redimension(x, schema, dim, FUN)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A SciDB array object of class scidb or scidbdf.</p>
</td></tr>
<tr valign="top"><td><code>schema</code></td>
<td>
<p>An optional SciDB array object of class scidb, scidbdf,
or a character string representation of the output array schema.</p>
</td></tr>
<tr valign="top"><td><code>dim</code></td>
<td>
<p>An optional character vector or list of new dimension names
from the *union* of dimension and attribute names of x, or
an integer positional index of a dimension of x.  Exactly
one of the <code>schema</code> and <code>dim</code> arguments must be specified.</p>
</td></tr>
<tr valign="top"><td><code>FUN</code></td>
<td>
<p>An optional reduction function or character SciDB aggregation expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Redimension</code> is a core SciDB operation. It can change the dimensionality,
shape, and partitioning of arrays, and transform array attributes into array
dimensions and vice versa. <code>Redimension</code> can also apply reduction functions
to values when dimensions are removed, similarly to group-by aggregation.
</p>
<p>The R package <code>redimension</code> function presents several forms. The most
direct form takes a SciDB array reference <code>x</code> and an desired output schema
<code>s</code> and directly applies the SciDB <code>redimension</code> operator.
</p>
<p>Alternatively, users may specify a character vector or list of <code>dim</code>
values that represent new array coordinate axes. These values should be a
subset of the union of attributes and dimension names in the input array
<code>x</code>. Note that they must also be valid <code>int64</code> types. If attributes
are selected that are not <code>int64</code>, then an attempt will be made to create
an auxilliary dimension array to enumerate unique attribute values.  References
to any created auxilliary arrays are placed in the dimnames list of the output
array (and can be inspected with <code>dimnames</code>, <code>rownames</code>,
codecolnames, etc.).
</p>
<p>When <code>redimension</code> reduces the dimensionality of an array, it's likely
that multiple values may fall into the same output array cell. When this
occurs, SciDB's default behavior randomly selects one of the possible values
for output. Alternatively, users may specify a reduction function in the
<code>FUN</code> argument or explicitly specify reductions using SciDB syntax in the
schema argument. The indicated reduction function will be applied to all the
attributes. You can also explicitly specify a character-valued SciDB
aggregation expression.
</p>
<p>If <code>FUN</code> contains a SciDB aggregation expression, it *must* declare
the name of each output attribute using the SciDB <code>AS</code> syntax. See
the examples.
</p>
<p>Reductions involving database user-defined types or aggregation functions
must explicitly specify an output schema.
</p>


<h3>Value</h3>

<p>A <code>scidb</code> object.
</p>


<h3>Note</h3>

<p>Use <code>eval=FALSE</code> to defer expression evaluation for efficiency. Results
can be composed to form complex query expressions that can be evaluated in one
transaction.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Upload iris to SciDB:
x &lt;- as.scidb(iris)

# bind an example new 'class' column:
y &lt;- bind(x, "class", "iif(Petal_Width&gt;2, int64(1), 0)")

# Data counts along a dimension:
z &lt;- redimension(y, dim="class", FUN=count)
# Example output:
##  z[]
##    0   1 
##  127  23 

# Contingency table along two dimensions:
z &lt;- redimension(y, dim=c("class", "Species"), FUN=count)
# Example output:
##  z[]
##  2 x 3 sparse Matrix of class "dgCMatrix"
##    setosa versicolor virginica
##  0     50         50        27
##  1      .          .        23

# More aggregation examples
set.seed(1)
A &lt;- bind(as.scidb(matrix(rnorm(25),5)), "m", 2)
redimension(A, dim="i",
  FUN="avg(m) as mavg, count(val) as count, min(val) as minval, sum(m) as msum")[]
# Example output:
##   mavg count      minval msum
## 0    2     5 -0.82046838   10
## 1    2     5 -0.01619026   10
## 2    2     5 -0.83562861   10
## 3    2     5 -2.21469989   10
## 4    2     5 -0.30538839   10


## End(Not run)</pre>


<table width="100%" summary="page for remove_old_versions"><tr><td>remove_old_versions</td><td align="right">R Documentation</td></tr></table>

<h2>
Remove all but most recent SciDB versions of an array.
</h2>

<h3>Description</h3>

<p>Remove all but most recent SciDB versions of an array.
</p>


<h3>Usage</h3>

<pre>
  remove_old_versions(stored_array)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>stored_array</code></td>
<td>
<p> A <code>scidb</code> or <code>scidbdf</code> object that refers
to a named, non-temporary SciDB array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL is invisibly returned on success, otherwise an error is thrown.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for rename"><tr><td>rename</td><td align="right">R Documentation</td></tr></table>

<h2>
Rename a SciDB array.
</h2>

<h3>Description</h3>

<p>Rename a SciDB array, returning a new reference object and optionally
setting persistence of the object.
</p>


<h3>Usage</h3>

<pre>
  rename(A, name=A@name, gc)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>A</code></td>
<td>
<p> A <code>scidb</code> or <code>scidbdf</code> object.  </p>
</td></tr>
<tr valign="top"><td><code>name</code></td>
<td>
<p>An optional new name for the object.</p>
</td></tr>
<tr valign="top"><td><code>gc</code></td>
<td>
<p>An optional logical value indicating object persistence. If
TRUE, then the backing SciDB array will be deleted by the R garbage collector
when corresponding R references are deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>scidb</code> or <code>scidbdf</code> object.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for repart"><tr><td>repart</td><td align="right">R Documentation</td></tr></table>

<h2>
repart
</h2>

<h3>Description</h3>

<p>The <code>repart</code> function is a wrapper to the SciDB 'repart' operator.
</p>


<h3>Usage</h3>

<pre>
repart(x, schema, upper, chunk, overlap, eval=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A SciDB array object of class scidb or scidbdf.</p>
</td></tr>
<tr valign="top"><td><code>schema</code></td>
<td>
<p>An optional character array schema.</p>
</td></tr>
<tr valign="top"><td><code>upper</code></td>
<td>
<p>An optional vector of new array upper bounds.</p>
</td></tr>
<tr valign="top"><td><code>chunk</code></td>
<td>
<p>An optional vector of new array chunk sizes.</p>
</td></tr>
<tr valign="top"><td><code>overlap</code></td>
<td>
<p>An optional vector of new array overlap values.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>scidb</code> object.
</p>


<h3>Note</h3>

<p>Repartition SciDB array data by chaning the array chunk sizes and/or
overlap values. This function is also used to change the upper bound of
an array coordinate axis.
</p>
<p>If <code>schema</code> is specified, the remaining shape arguments are ignored.
</p>
<p>The arguments <code>upper, chunk</code>, and <code>overlap</code> must each have the same
number of elements as the dimension of the SciDB array <code>x</code>. The
<code>upper</code> argument should contain double-precision integer values (standard
R array index values). The <code>chunk</code> and <code>overlap</code> arguments should
contain integer values.
</p>
<p>Optional arguments left unspecified remain unchanged in the output array.
</p>
<p>Use <code>eval=FALSE</code> to defer expression evaluation for efficiency. Results
can be composed to form complex query expressions that can be evaluated in one
transaction.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Add chunk overlap to an array:

x &lt;- as.scidb(iris)
y &lt;- repart(x, overlap=3)

## End(Not run)</pre>


<table width="100%" summary="page for replaceNA"><tr><td>replaceNA</td><td align="right">R Documentation</td></tr></table>

<h2>
Replace SciDB NULL values with another value.
</h2>

<h3>Description</h3>

<p>Replace SciDB NULL (aka missing) values with another value.
</p>


<h3>Usage</h3>

<pre>
replaceNA (x, value, `attribute`, `eval`=FALSE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code>  or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>value</code></td>
<td>
<p>An optional scidb array containing the replacement value.</p>
</td></tr>
<tr valign="top"><td><code>attribute</code></td>
<td>
<p>An optional attribute to restrict NULL replacement to.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This R function corresponds to SciDB's <code>substitute</code> operator.
</p>
<p>If <code>value</code> is missing, a value of numeric zero, false, or the string &quot;0&quot; will be used
to replace NULL values depending on the replacement attribute type.
</p>
<p>If <code>attribute</code> is missing, then an attempt will be made to replace all NULL values in the
array.
</p>


<h3>Value</h3>

<p>A new <code>scidb</code> or <code>scidbdf</code> object.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- scidb("build(&lt;v:double null&gt;[i=1:3,3,0],'{1}[(null),(null),(null)]',true)")
y &lt;- replaceNA(x)

## End(Not run)</pre>


<table width="100%" summary="page for reshape-methods"><tr><td>reshape-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Methods for Function <code>reshape</code> in Package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p>Change the dimensionality of a SciDB array object.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
reshape(data, schema, shape, dimnames, start, chunks, `eval`=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>data</code></td>
<td>
<p>A <code>scidb</code> array object.</p>
</td></tr>
<tr valign="top"><td><code>schema</code></td>
<td>
<p>Optional character-valued schema.</p>
</td></tr>
<tr valign="top"><td><code>shape</code></td>
<td>
<p>An integer vector of new dimension sizes.</p>
</td></tr>
<tr valign="top"><td><code>dimnames</code></td>
<td>
<p>An optional integer vector of new dimension names.</p>
</td></tr>
<tr valign="top"><td><code>start</code></td>
<td>
<p>An optional integer vector of new dimension starting coordinates.</p>
</td></tr>
<tr valign="top"><td><code>chunks</code></td>
<td>
<p>An optional integer vector of new dimension chunk sizes.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>schema</code> is specified the other shape arguments are ignored.
</p>
<p>The product of the entries of the <code>shape</code> vector must match the product of
the dimensions of <code>data</code>.
</p>
<p>The optional <code>dimnames</code>, <code>start</code> and <code>chunks</code> arguments must
match the length of <code>shape</code> if they are supplied.
</p>
<p>If not specified in either <code>schema</code> or <code>start</code>, the output
array will start at the origin.
</p>


<h3>Value</h3>

<p>A <code>scidb</code> reference object. </p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Create a 5 x 4 matrix
X &lt;- as.scidb(matrix(rnorm(20),5))

# Reshape into a 3-dimensional 2x2x5 array
Y &lt;- reshape(X, c(2,2,5))

## End(Not run)
</pre>


<table width="100%" summary="page for schema"><tr><td>schema</td><td align="right">R Documentation</td></tr></table>

<h2>
schema
</h2>

<h3>Description</h3>

<p>Return the SciDB array schema.
</p>


<h3>Usage</h3>

<pre>
schema(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>An object of class <code>scidb</code> or <code>scidbdf</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The SciDB array schema.
</p>


<h3>Note</h3>

<p>This function is nearly equivalent to <code>x@schema</code>.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Upload data to create a 10x10 SciDB matrix
A &lt;- as.scidb(matrix(rnorm(100),10))
schema(A)
A@schema

## End(Not run)</pre>


<table width="100%" summary="page for scidb_attributes"><tr><td>scidb_attributes</td><td align="right">R Documentation</td></tr></table>

<h2>
Scidb schema utilities
</h2>

<h3>Description</h3>

<p>Return a vector of SciDB array attribute names, types,
nullable-ness, coordinate bounds, overlap, and coordinate
start and end bounds.
</p>


<h3>Usage</h3>

<pre>
scidb_attributes(x)
scidb_types(x)
scidb_nullable(x)
scidb_coordinate_bounds(x)
scidb_coordinate_chunksize(x)
scidb_coordinate_overlap(x)
scidb_coordinate_start(x)
scidb_coordinate_end(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>An object of class <code>scidb</code> or <code>scidbdf</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of SciDB array dimension names, types,
nullable-ness, coordinate bounds, chunk sizes, chunk overlap amount,
or coordinate starting or ending indices, respectively.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Upload data to create a 10x10 SciDB matrix
A &lt;- as.scidb(matrix(rnorm(100),10))
scidb_attributes(A)

## End(Not run)</pre>


<table width="100%" summary="page for scidb-class"><tr><td>scidb-class</td><td align="right">R Documentation</td></tr></table>

<h2>Class <code>"scidb"</code></h2>

<h3>Description</h3>

<p>A class that represents SciDB arrays as R arrays.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("scidb", ...)</code>,
<code>scidb("ARRAY_NAME", ...)</code>, or <code>as.scidb(R_MATRIX, ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Object of class <code>"character"</code> scidb array name. </p>
</dd>
<dt><code>attributes</code>:</dt><dd><p>Object of class <code>"character"</code> Vector of SciDB attribute names. </p>
</dd>
<dt><code>dimensions</code>:</dt><dd><p>Object of class <code>"character"</code> Vector of SciDB dimension names. </p>
</dd>
<dt><code>schema</code>:</dt><dd><p>Object of class <code>"character"</code> SciDB array schema. </p>
</dd>
<dt><code>logical_plan</code>:</dt><dd><p>Object of class <code>"character"</code> SciDB array plan. </p>
</dd>
<dt><code>gc</code>:</dt><dd><p>Object of class <code>"environment"</code> An environment used to link the SciDB array to the R garbage collector. </p>
</dd>
<dt><code>.S3Class</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>%*%</dt><dd><p><code>signature(x = "scidb", y = "scidb")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "scidb", y = "matrix")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "matrix", y = "scidb")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "scidb", y = "numeric")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "numeric", y = "scidb")</code>: ... </p>
</dd>
<dt>%*%</dt><dd><p><code>signature(x = "scidb", y = "scidbdf")</code>: ... </p>
</dd>
<dt>crossprod</dt><dd><p><code>signature(x = "scidb", y = "scidb")</code>: ... </p>
</dd>
<dt>tcrossprod</dt><dd><p><code>signature(x = "scidb", y = "scidb")</code>: ... </p>
</dd>
<dt>crossprod</dt><dd><p><code>signature(x = "scidb", y = "missing")</code>: ... </p>
</dd>
<dt>tcrossprod</dt><dd><p><code>signature(x = "scidb", y = "missing")</code>: ... </p>
</dd>
<dt>is.scidb</dt><dd><p><code>signature(x = "ANY")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "scidb")</code>: ... </p>
</dd>
<dt>head</dt><dd><p><code>signature(x = "scidb")</code>: ... </p>
</dd>
<dt>tail</dt><dd><p><code>signature(x = "scidb")</code>: ... </p>
</dd>
<dt>apply</dt><dd><p><code>signature(x = "scidb")</code>: ... </p>
</dd>
<dt>regrid</dt><dd><p><code>signature(x = "scidb")</code>: <code>regrid(x, grid=c(m,...), expr="avg(attribute)")</code>
Decimate the n-d SciDB array <code>x</code> by binning its coordinate system according to the <code>grid</code> argument and applying the aggregate expression on each bin. The <code>grid</code> argument must be the same length as the dimension of the array <code>x</code>. For example if <code>x</code> is a 10x10 matrix, then <code>regrid(x, c(2,1))</code> returns a 5x10 matrix replacing the rows with the average of values along every two rows.
</p>
</dd>
<dt>xgrid</dt><dd><p><code>signature(x = "scidb")</code>: <code>xgrid(x, grid=c(m,...))</code>
Prolong the coordinate system of the n-d SciDB array <code>x</code> by replicating its values according to the <code>grid</code> parameter. In some cases, <code>xgrid</code> can be the inverse operation of <code>regrid</code>. For example if <code>x</code> is a 10x10 matrix, then <code>xgrid(x, c(2,1))</code> returns a 20x10 matrix, replicating values twice along the row dimension.
</p>
</dd>
<dt>Filter</dt><dd><p><code>signature(f="character", x = "scidb")</code>: <code>Filter(f,x)</code>
'Filter' masks elements of a vector for which a predicate (logical) SciDB expression 'f' returns false by making them empty, returning a sparse version of the array.
</p>
</dd>
<dt>image</dt><dd><p><code>signature(x = "scidb")</code>: <code>image(x, grid=c(m,n), op="sum(attribute)")</code>
Display a heatmap-like image of the 2-d scidb array reference object <code>x</code>.
<code>grid(m,n)</code> specifies the repartitioned array block sizes and <code>op</code> is a valid SciDB aggregation function applied to the repartitioned chunks. </p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "scidb")</code>: Return the diagonal of a SciDB matrix as a new 1d SciDB array (a vector). NOTE that the result vector is zero-indexed.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "scidb")</code>: ... </p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "scidb")</code>: <code>t(x)</code>
Return the transpose of the matrix <code>x</code>.
</p>
</dd>
<dt>unpack</dt><dd><p><code>unpack(x = "scidb")</code>: <code>unpack(x)</code>
Return a 1-D representation of an array using the SciDB array unpack operator.
</p>
</dd>
<dt>diag</dt><dd><p><code>signature(x = "scidb")</code>: Return the diagonal of a SciDB matrix as a new 1d SciDB array (a vector).</p>
</dd>
<dt>sin</dt><dd><p><code>signature(x = "scidb")</code>: <code>sin(x)</code>
Return an array with the sine of each element of the array <code>x</code>. The active attribute is used and should be numeric. The returned array contains a new attibute with &quot;_sin&quot; appended containing the result. Other trig functions (<code>cos, tan, asin, acos, atan</code>) act similarly.
</p>
</dd>
<dt>abs</dt><dd><p><code>signature(x = "scidb")</code>: <code>abs(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>sqrt</dt><dd><p><code>signature(x = "scidb")</code>: <code>sqrt(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>exp</dt><dd><p><code>signature(x = "scidb")</code>: <code>exp(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>sin</dt><dd><p><code>signature(x = "scidb")</code>: <code>sin(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>cos</dt><dd><p><code>signature(x = "scidb")</code>: <code>cos(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>tan</dt><dd><p><code>signature(x = "scidb")</code>: <code>tan(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>asin</dt><dd><p><code>signature(x = "scidb")</code>: <code>asin(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>acos</dt><dd><p><code>signature(x = "scidb")</code>: <code>acos(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>atan</dt><dd><p><code>signature(x = "scidb")</code>: <code>atan(x)</code> See doc. for <code>sin</code>.</p>
</dd>
</dl>



<h3>Notes</h3>

<p>SciDB arrays are general n-dimensional sparse arrays with integer dimensions.
The <code>scidb</code> class represents SciDB arrays in a way that mimics standard R
arrays in many ways. The <code>scidbdf</code> class represents one-dimensional SciDB
arrays with one or more attributes that mimic R data frames.
</p>
<p>Matrix arithmetic operations are overloaded for 2-D numeric arrays.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<table width="100%" summary="page for scidbconnect"><tr><td>scidbconnect</td><td align="right">R Documentation</td></tr></table>

<h2>Connect to a SciDB database.  </h2>

<h3>Description</h3>

<p>Connect to a SciDB database.
</p>


<h3>Usage</h3>

<pre>
scidbconnect(host=options("scidb.default_shim_host")[[1]],
             port=options("scidb.default_shim_port")[[1]],
             username, password,
             auth_type=c("pam","digest"),
             protocol=c("http","https"))
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>host</code></td>
<td>

<p>The host name or I.P. address of the SciDB database
instance to connect to (character).
</p>
</td></tr>
<tr valign="top"><td><code>port</code></td>
<td>

<p>The integer port number of the SciDB database simple HTTP service.
The default shim ports are 8080 (open) and 8083 (SSL encrypted).
</p>
</td></tr>
<tr valign="top"><td><code>username</code></td>
<td>
<p>Optional authentication username (character).</p>
</td></tr>
<tr valign="top"><td><code>password</code></td>
<td>
<p>Optional authentication password (character).</p>
</td></tr>
<tr valign="top"><td><code>auth_type</code></td>
<td>
<p>Optinal authentication method. The
<code>auth_type</code> parameter is only used when a <code>username</code> and
<code>password</code> are supplied. It defaults to 'pam'
which uses local Linux user names and passwords on the SciDB system.
Select 'digest' to use basic HTTP digest authentication. See the
<code>shim</code> documentation for details
<a href="http://htmlpreview.github.io/?https://raw.github.com/Paradigm4/shim/master/wwwroot/help.html">http://htmlpreview.github.io/?https://raw.github.com/Paradigm4/shim/master/wwwroot/help.html</a>.</p>
</td></tr>
<tr valign="top"><td><code>protocol</code></td>
<td>
<p>Optional transport protocol, defaults to 'http.'
Select 'https' for TLS encryption. Note that the 'pam' authenitication
type automatically uses TLS encryption.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SciDB connection state is maintained internally to the <code>scidb</code>
package. We internalize state to facilitate operations involving <code>scidb</code>
objects.
</p>
<p>Thus, only one open SciDB connection is supported at
a time.
</p>
<p>One may connect to and use multiple SciDB databases by sequentially calling
<code>scidbconnect</code> between operations. Note that <code>scidb</code> objects are not
valid across different SciDB databases.
</p>
<p>Use the optional <code>username</code> and <code>password</code> arguments to authenticate
the connection with the shim service. PAM-authenticated connections require 
an encrypted connection with shim, available by default on port 8083.
</p>
<p>Use the optional <code>username</code> and <code>password</code> arguments with
<code>auth_type</code> set to &quot;digest&quot; to use HTTP digest authentication (see the
shim documentation to configur this).  Digest authentication may use either
&quot;http&quot; or &quot;https&quot; transports selected by the <code>protocol</code> setting.
</p>


<h3>Value</h3>

<p>NULL is invisibly returned. SciDB connection errors
are propagated to R and may be handled with the usual
R error handling mechanisms.
</p>


<h3>Note</h3>

<p>Disconnection is automatically handled by the package.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for scidbdf-class"><tr><td>scidbdf-class</td><td align="right">R Documentation</td></tr></table>

<h2>Class <code>"scidbdf"</code></h2>

<h3>Description</h3>

<p>A class that represents 1D SciDB arrays similarly to R data.frames.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("scidbdf", ...)</code>,
<code>scidb("ARRAY_NAME", ...)</code>, or <code>as.scidb(R_DATA_FRAME, ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>Object of class <code>"character"</code> scidb array name. </p>
</dd>
<dt><code>attributes</code>:</dt><dd><p>Object of class <code>"character"</code> Vector of SciDB attribute names. </p>
</dd>
<dt><code>dimensions</code>:</dt><dd><p>Object of class <code>"character"</code> Vector of SciDB dimension names. </p>
</dd>
<dt><code>schema</code>:</dt><dd><p>Object of class <code>"character"</code> SciDB array schema.</p>
</dd> 
<dt><code>logical_plan</code>:</dt><dd><p>Object of class <code>"character"</code> SciDB array plan. </p>
</dd>
<dt><code>gc</code>:</dt><dd><p>Object of class <code>"environment"</code> An environment used to link the SciDB array to the R garbage collector. </p>
</dd>
<dt><code>.S3Class</code>:</dt><dd><p>Object of class <code>"character"</code> ~~ </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>is.scidbdf</dt><dd><p><code>signature(x = "scidbdf")</code>: ... </p>
</dd>
<dt>is.scidbdf</dt><dd><p><code>signature(x = "ANY")</code>: ... </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "scidbdf")</code>: ... </p>
</dd>
<dt>head</dt><dd><p><code>signature(x = "scidbdf")</code>: ... </p>
</dd>
<dt>tail</dt><dd><p><code>signature(x = "scidbdf")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "scidbdf")</code>: ... </p>
</dd>
<dt>Filter</dt><dd><p><code>signature(f="character", x = "scidbdf")</code>: <code>Filter(f,x)</code>
'Filter' masks elements of a vector for which a predicate (logical) SciDB expression 'f' returns false by making them empty, returning a sparse version of the array.
</p>
</dd>
<dt>sin</dt><dd><p><code>signature(x = "scidbdf")</code>: <code>sin(x)</code>
Return an array with the sine of each element of the array <code>x</code>. The first listed attribute is used and should be numeric. The returned array contains a new attibute with &quot;_sin&quot; appended containing the result. Additional trig functions (<code>cos, tan, asin, acos, atan</code>) act similarly.
</p>
</dd>
<dt>abs</dt><dd><p><code>signature(x = "scidbdf")</code>: <code>abs(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>sqrt</dt><dd><p><code>signature(x = "scidbdf")</code>: <code>sqrt(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>exp</dt><dd><p><code>signature(x = "scidbdf")</code>: <code>exp(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>cos</dt><dd><p><code>signature(x = "scidbdf")</code>: <code>cos(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>tan</dt><dd><p><code>signature(x = "scidbdf")</code>: <code>tan(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>asin</dt><dd><p><code>signature(x = "scidbdf")</code>: <code>asin(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>acos</dt><dd><p><code>signature(x = "scidbdf")</code>: <code>acos(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>atan</dt><dd><p><code>signature(x = "scidbdf")</code>: <code>atan(x)</code> See doc. for <code>sin</code>.</p>
</dd>
<dt>unpack</dt><dd><p><code>unpack(x = "scidbdf")</code>: <code>unpack(x)</code>
Return a 1-D representation of an array using the SciDB array unpack operator.
</p>
</dd>
<dt>regrid</dt><dd><p><code>signature(x = "scidbdf")</code>: <code>regrid(x, grid, expr)</code>
Decimate the n-d SciDB array <code>x</code> by binning its coordinate system according to the <code>grid</code> argument and applying the aggregate expression on each bin. The <code>grid</code> argument must be the same length as the dimension of the array <code>x</code>. For example if <code>x</code> is a 10x10 matrix, then <code>regrid(x, c(2,1))</code> returns a 5x10 matrix replacing the rows with the average of values along every two rows.
</p>
</dd>
<dt>xgrid</dt><dd><p><code>signature(x = "scidbdf")</code>: <code>xgrid(x, grid=c(m,...))</code>
Prolong the coordinate system of the n-d SciDB array <code>x</code> by replicating its values according to the <code>grid</code> parameter. In some cases, <code>xgrid</code> can be the inverse operation of <code>regrid</code>. For example if <code>x</code> is a 10x10 matrix, then <code>xgrid(x, c(2,1))</code> returns a 20x10 matrix, replicating values twice along the row dimension.
</p>
</dd>
</dl>



<h3>Notes</h3>

<p>Like the related <code>scidb</code> class, the <code>scidbdf</code> class represents
SciDB arrays as R objects. The <code>scidbdf</code> class presents 1-D SciDB arrays,
potentially with many SciDB attributes (variables), as a data.frame-like object.
</p>
<p>Use the special empty-bracket index <code>[]</code> to return data from SciDB to R.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for scidbdisconnect"><tr><td>scidbdisconnect</td><td align="right">R Documentation</td></tr></table>

<h2>
Disconnect from a SciDB database.
</h2>

<h3>Description</h3>

<p>SciDB connections are automatically disconnected by the package
in normal practice. The <code>scidbdisconnect</code> function forces
the current connection to disconnect.
</p>


<h3>Usage</h3>

<pre>
scidbdisconnect()
</pre>


<h3>Value</h3>

<p>NULL is invisibly returned.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for scidbeval"><tr><td>scidbeval</td><td align="right">R Documentation</td></tr></table>

<h2>
scidbeval
</h2>

<h3>Description</h3>

<p>Evaluate a SciDB expression.
</p>


<h3>Usage</h3>

<pre>
scidbeval(expr, eval=TRUE, name, gc=TRUE, temp=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>expr</code></td>
<td>
<p>An R expression that evaluates to a 'scidb' or 'scidbdf' object.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>If TRUE, return a 'scidb' or 'scidbdf' object that has been evaluated by
the databas and stored to a SciDB array.</p>
</td></tr>
<tr valign="top"><td><code>name</code></td>
<td>
<p>An optional character value that names the stored SciDB array.</p>
</td></tr>
<tr valign="top"><td><code>gc</code></td>
<td>
<p>An optional logical value that, when TRUE, ties the result to the R garbage collector.</p>
</td></tr>
<tr valign="top"><td><code>temp</code></td>
<td>
<p>An optional logical value that, when TRUE, evaluates to a special SciDB
temporary array (requires SciDB versions equal to or greater than 14.8).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code>scidb</code> or <code>scidbdf</code> object.
</p>


<h3>Note</h3>

<p>Use <code>eval=FALSE</code> to defer expression evaluation for efficiency. Many
functions in the SciDB package accept un-evaluated expresions. One can compose
these objects to form complex query expressions that can be evaluated in one
transaction.
</p>
<p>Use SciDB temporary arrays with caution. They can speed up some
computations by avoiding disk storage in some cases, but are not
transactionally protected.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
A &lt;- as.scidb(matrix(rnorm(25),5))
B &lt;- A + A   # Returns a SciDB array promise (not evaluated yet)
C &lt;- scidbeval(A + A) # Returns a SciDB array that has been evaluated and stored

## End(Not run)</pre>


<table width="100%" summary="page for scidb_fisher.test"><tr><td>scidb_fisher.test</td><td align="right">R Documentation</td></tr></table>

<h2>
scidb_fisher.test
</h2>

<h3>Description</h3>

<p>Performs Fisher's exact test for testing the null of independence
of rows and columns in a contingency table with fixed marginals.
</p>


<h3>Usage</h3>

<pre>
scidb_fisher.test(a,x="x",m="m",n="n",k="k",alternative="two.sided", `eval`=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>a</code></td>
<td>
<p> a <code>scidb</code> array or <code>scidbdf</code> data frame object.</p>
</td></tr>
<tr valign="top"><td><code>x</code></td>
<td>
<p>The x value attribute name (see details below).</p>
</td></tr>
<tr valign="top"><td><code>m</code></td>
<td>
<p>The m marginal value attribute name (see details below).</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p>The m marginal value attribute name (see details below).</p>
</td></tr>
<tr valign="top"><td><code>k</code></td>
<td>
<p>The m marginal value attribute name (see details below).</p>
</td></tr>
<tr valign="top"><td><code>alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be one of
'&quot;two.sided&quot;', '&quot;greater&quot;' or '&quot;less&quot;'.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If TRUE, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For 2 by 2 tables, the null of conditional independence is equivalent to the
hypothesis that the odds ratio equals one. &quot;Exact&quot; inference can be based on
observing that in general, given all marginal totals fixed, the first element
of the contingency table has a non-central hypergeometric distribution with
non-centrality parameter given by the odds ratio (Fisher, 1935).
</p>
<p>Consider the following 2x2 contingency table:
</p>

<table summary="Rd table">
<tr>
 <td align="left">
</td><td align="center"> Class I YES</td><td align="center"> Class I NO</td><td align="center"> SUM</td>
</tr>
<tr>
 <td align="left">
Class II YES</td><td align="center"> x</td><td align="center"> a</td><td align="center"> k = x + a</td>
</tr>
<tr>
 <td align="left">
Class II NO</td><td align="center"> b</td><td align="center"> c</td><td align="center"> </td>
</tr>
<tr>
 <td align="left">
SUM</td><td align="center"> m = x + b</td><td align="center"> n = a + c</td><td align="center"> </td>
</tr>
<tr>
 <td align="left">
</td>
</tr>

</table>

<p>The <code>x</code> input value specifies the name of the SciDB array attribute that
indicates the number of 'yes' events in both classifications.
The <code>m</code> input value specifies the name of the SciDB array attribute that
indicates the marginal sum of the first column.
The <code>n</code> input value specifies the name of the SciDB array attribute that
indicates the marginal sum of the second column.
The <code>k</code> input value specifies the name of the SciDB array attribute that
indicates the marginal sum of the first row.
</p>


<h3>Value</h3>

<p>A new SciDB array with two new attributes is returned (note that the returned attribute
names may be adjusted to account for naming conflicts with existing array attributes):
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>pvalue</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr valign="top"><td><code>estimate</code></td>
<td>
<p>an estimate of the odds ratio.  Note that the conditional
Maximum Likelihood Estimate (MLE) rather than the
unconditional MLE (the sample odds ratio) is used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
<code>phyper</code>
<code>qhyper</code>
<code>dhyper</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Create a test array:
a &lt;- scidb("apply(build(&lt;x:int64&gt;[i=0:0,1,0],2),m,12,n,18,k,17)")
scidb_fisher.test(a)[]

# output looks like:
#   x  m  n  k         pval   estimate
# 0 2 12 18 17 0.0005367241 0.04693664


## End(Not run)</pre>


<table width="100%" summary="page for scidblist"><tr><td>scidblist</td><td align="right">R Documentation</td></tr></table>

<h2>
List SciDB database items.
</h2>

<h3>Description</h3>

<p>List arrays and various other items available in a SciDB database.
</p>


<h3>Usage</h3>

<pre>
scidblist(pattern, type = c("arrays", "operators", "functions", "types",
                            "aggregates", "instances","queries","libraries"),
          verbose = FALSE, n = Inf)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>pattern</code></td>
<td>

<p>Filter the list by a regular-expression style pattern.
</p>
</td></tr>
<tr valign="top"><td><code>type</code></td>
<td>

<p>A character string indicating the type of SciDB item to list&ndash;defaults to 'array.'
</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>

<p>Include extra available information for some items (arrays, in particular).
</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>

<p>Maximum number of rows to return.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of listed items.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# List information about the SciDB cluster we're connected to:
scidblist('instances')

# List all arrays:
scidblist()

# List all arrays beginning with "A:"
scidblist(pattern="^A")

## End(Not run)</pre>


<table width="100%" summary="page for scidb-package"><tr><td>scidb-package</td><td align="right">R Documentation</td></tr></table>

<h2> SciDB interface package.  </h2>

<h3>Description</h3>

<p>The scidb package provides basic functions
that move data between R and SciDB and issue SciDB queries.
</p>
<p>The package defines two R classes that facilitate programming with
SciDB. The <code>scidb</code> class defines an n-dimensional sparse array
class. The <code>scidbdf</code> class defines a data frame class. Data
for <code>scidb</code> and <code>scidbdf</code> objects are backed by the
SciDB database and operations on them are conducted by SciDB.
</p>


<h3>Details</h3>


<table summary="Rd table">
<tr>
 <td align="left">
Package: </td><td align="left"> scidb</td>
</tr>
<tr>
 <td align="left">
Type: </td><td align="left"> Package</td>
</tr>
<tr>
 <td align="left">
Version: </td><td align="left"> 0.0</td>
</tr>
<tr>
 <td align="left">
Date: </td><td align="left"> 2012-07-18</td>
</tr>
<tr>
 <td align="left">
License: </td><td align="left"> GPL3</td>
</tr>
<tr>
 <td align="left">
Depends: </td><td align="left"> methods</td>
</tr>
<tr>
 <td align="left">
</td>
</tr>

</table>

<p>Package options:
</p>

<ul>
<li> <p><code>options(scidb.index.sequence.limit=1000000)</code> Maximum allowed sequential index limit (for larger use between)
</p>
</li>
<li> <p><code>options(scidb.max.array.elements=100000000)</code> Maximum allowed elements in an array return result
</p>
</li>
<li> <p><code>options(scidb.version=13.9)</code> The scidb.version option is set during scidbconnect(). However, users may carefully override it to enable certain bug fixes specific to older versions of SciDB
</p>
</li>
<li> <p><code>options(scidb.gemm_chunk_size=1000)</code> Default gemm chunk size
</p>
</li>
<li> <p><code>options(scidb.default_shim_port=8080L)</code> Default shim port
</p>
</li>
<li> <p><code>options(scidb.default_shim_host="localhost")</code> Default shim host
</p>
</li>
<li> <p><code>options(scidb.safe_remove=TRUE)</code> Require <code>force=TRUE</code> to remove non-session arrays
</p>
</li>
<li> <p><code>options(scidb.verifyhost=FALSE)</code> Set TRUE to reverse host lookup in SSL sessions
</p>
</li>
<li> <p><code>options(scidb.interrupt=TRUE)</code> Set FALSE to disable user interruptable HTTP transactions
</p>
</li>
<li> <p><code>options(scidb.stream=FALSE)</code> Set TRUE to enable streaming data through the shim interface to SciDB (avoids copying query output data to a file on the server), see <a href="https://github.com/Paradigm4/shim">https://github.com/Paradigm4/shim</a>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>
<p>Maintainer: B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<table width="100%" summary="page for scidb"><tr><td>scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
Create a <code>scidb</code> reference object.
</h2>

<h3>Description</h3>

<p>Create an array-like R object reference to a SciDB array.
</p>


<h3>Usage</h3>

<pre>
scidb(name, gc, `data.frame`)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>name</code></td>
<td>
<p>Name of the SciDB array to reference. </p>
</td></tr>
<tr valign="top"><td><code>gc</code></td>
<td>
<p>TRUE means SciDB array shall be removed when R object is garbage collected or R exits. FALSE means SciDB array persists.</p>
</td></tr>
<tr valign="top"><td><code>data.frame</code></td>
<td>
<p>Return a data.frame-like object (requires 1D SciDB array).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The referenced array may be any SciDB array. One-dimensional SciDB arrays
may be represented as data.frame-like objects in which the SciDB array
attributes appear as data.frame columns. Alternatively, 1-d SciDB arrays
may be represented as vectors by setting <code>data.frame=FALSE</code>.
</p>
<p>SciDB arrays of dimension 2 or more appear as R arrays.
</p>
<p>Data frame like representations use the <code>scidbdf</code> class.
N-d array objects and vectors use the <code>scidb</code> class.
</p>
<p>The <code>scidb</code> class supports sparse and dense SciDB arrays of any dimension.
Attribute types real, integer (32-bit), logical, and single-character (one
byte) are directly supported and may be downloaded to R. Other SciDB attribute
types are indirectly supported.
</p>
<p>R does not have a native 64-bit integer type. SciDB uses signed 62-bit integer
dimensions.  The <code>scidb</code> package uses R double-precision floating point
integers to index SciDB integer dimensions, restricting R to dimension values
below 2^(53).
</p>
<p>With the exception of the empty indexing operation, <code>[]</code>, subarray
indexing operations return new SciDB reference array objects.  Use the empty
indexing operation to materialize data from the SciDB backing array into a
normal R array.
</p>
<p>Sparse SciDB matrices (2-d arrays) are materialized to R as sparse matrices.
Higher dimensional sparse arrays are returned as lists of indices and values.
See the vignette examples for a more compete discussion of sparsity and various
indexing operations.
</p>


<h3>Value</h3>

<p>A <code>scidb</code> object that references the indicated
SciDB array.
</p>


<h3>Indexing</h3>

<p>The <code>scidb</code> and <code>scidbdf</code> classes generally follow SciDB database
indexing convention, which exhibits some differences with standard R indexing.
In particular, note that the starting SciDB integer index is arbitrary, but
often zero. The upper-left corner of R arrays is always indexed by [1,1,...].
Subarray indexing operations use the SciDB convention. Thus, zero and negative
indices are literally interpreted and passed to SciDB. In particular, negative
indices do not indicate index omission, unlike standard R arrays.
</p>
<p>Additional indexing notes:
</p>

<ul>
<li><p> Use empty brackets, <code>[]</code>, to materialize data back to R. Otherwise,
indexing operations produce new SciDB array objects.
</p>
</li>
<li><p> Use numeric indices in any dimension in the units of the underlying SciDB
array coordinate system. Note that SciDB arrays generally are zero-indexed
and may even have negative indices.
</p>
</li>
<li><p> Numeric indexing may include contiguous ranges or vectors of distinct
coordinate values, but repeated coordinate values in a single dimension are
not allowed. Examples of valid index ranges include
<code>[1:4, c(3,1,5), -10:15]</code>, but not <code>[c(1,3,1)]</code> for example.
</p>
</li>
<li><p> The <code>scidbdf</code> class represents 1d SciDB arrays as data frame
objects with array attributes as columns. Use either positional numeric
or name-based indexing along columns, either with the dollar-sign notation
or string indexing. See examples.
</p>
</li>
<li><p> The <code>scidb</code> class supports labeled dimension indexing using
R <code>rownames, colnames</code>, or <code>dimnames</code> settings. Labels assigned
in this way must be provided by 1-d SciDB arrays that map the integer
coordinates to character label values. See the examples.
</p>
</li>
<li><p> The <code>scidb</code> class supports indexing by other SciDB arrays
to achieve the effect of filtering by boolean expressions and similar
operations, also illustrated below in the examples section.
</p>
</li>
<li><p> Use the utility between function to avoid forming large sequences to
represent huge indexing ranges. For example, use <code>[between(1,1e9)]</code>
instead of <code>[1:1e9]</code>.
</p>
</li>
<li><p> The <code>diag</code> function is supported for matrices and vectors.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>between,diag,slice</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
scidbconnect()
# A 1-d array representation as a data frame:
data("iris")
A &lt;- as.scidb(iris)
# Inspect the backing SciDB array object details with str:
str(A)

# Subsetting returns a new SciDB array:
A[1:2,]

# Materialize data to R with empty brackets:
A[1:2,][]

# Subset data frame-like object columns with 1-based positional or character
# indices. The following are all the same:
A[,"Species"]
A$Species
A[,5]

# Represent the 1-d array as a vector-like object instead:
a &lt;- scidb(A, data.frame=FALSE)
# Interrogate the SciDB array properties with str:
str(a)

# A matrix:
set.seed(1)
X &lt;- as.scidb( matrix(rnorm(20), nrow=5) )
# Diagonal entries of X:
diag(X)
# A sparse matrix with just the diagonal of X:
D = diag(diag(X))
# Materialize this sparse array to R:
D[]

# Produce a sparse matrix of filtered entries and materialize to R:
subset(X, "val &gt; 0")[]

# Short-hand for the same effect:
(X &gt; 0)[]

# Assign row labels to X. Note! We make sure that the index array starts at the
# same starting index as the matrix (zero in this example):
rownames(X) &lt;- as.scidb(data.frame(letters[1:5]),start=0)
# Index by label:
X[c("c","a"), ]

# Filter X by an auxillary SciDB array condition (we use the rownames array),
# returning the result to R:
X[rownames(X) &gt; "'b'", ][]


# A 3-d array:
X &lt;- build(dim=c(3,2,2),names=c("x","i","j","k"),data="i+j+k")

# A sparse 3-d array filtered with subset:
Y &lt;- subset(X, "x&gt;1")
count(Y)
Y[]

## End(Not run)</pre>


<table width="100%" summary="page for scidbremove"><tr><td>scidbremove</td><td align="right">R Documentation</td></tr></table>

<h2>
Remove an array.
</h2>

<h3>Description</h3>

<p>Remove (delete) an array from SciDB.
</p>


<h3>Usage</h3>

<pre>
scidbremove(x, error = warning, async, force, warn=TRUE, recursive=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>

<p>The name of the SciDB array to remove (character), or 
a vector of array names to remove, or a <code>scidb</code> or <code>scidbdf</code>
object.
</p>
</td></tr>
<tr valign="top"><td><code>error</code></td>
<td>
<p>Error handling function.</p>
</td></tr>
<tr valign="top"><td><code>async</code></td>
<td>
<p>(Optional) logical: If TRUE, use async option in newer
versions of SciDB shim interface to return faster by not waiting
for the query to complete. The default value is FALSE.</p>
</td></tr>
<tr valign="top"><td><code>force</code></td>
<td>
<p>(Optional) logical: If TRUE, force removal of specified array,
even if the <code>scidb.safe_remove</code> option is set to <code>TRUE</code>.</p>
</td></tr>
<tr valign="top"><td><code>warn</code></td>
<td>
<p>(Optional) logical: Set to FALSE to disable warnings during removal.</p>
</td></tr>
<tr valign="top"><td><code>recursive</code></td>
<td>
<p>(Optional) logical: If true, remove the entire dependency graph of
this array from SciDB.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Supply a user-defined error handling function to avoid stopping on error (for
example trying to delete a non-existing array). For example, use
<code>error=warning</code> to covert errors to warnings but still report them.
</p>
<p>The package option <code>scidb.safe_remove</code> adds some protection for
accidentally removing arrays. When <code>TRUE</code> (the default value), only
temporary arrays associated with the current R session can be removed without
also setting the <code>force</code> option.  Specify <code>force=TRUE</code> to remove any
specified array, or optionally set the <code>options(scidb.safe_remove=FALSE)</code>
to disable this safety check.
</p>
<p>The <code>async</code> option does not really do anything yet. It will in a future
version.
</p>
<p>Use <code>recursive=TRUE</code> with great care. It recursively calls <code>scidbremove</code>
on the entire dependency graph of an array object.
</p>


<h3>Value</h3>

<p>NULL is invisibly returned. SciDB errors are returned as
normal R errors and may be handled accordingly.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
data("iris")
x = as.scidb(iris)
# This is the SciDB array name corresponding to x:
print(x@name)

# Let's make an array with a different name:
y = as.scidb(iris, name="iris")
print(y@name)

# Removing everything will only delete arrays whose name begin with
# R_array by default:
scidbremove(scidblist())
scidblist()

# To remove the 'iris' array, use force=TRUE:
scidbremove("iris", force=TRUE)
scidblist()

## End(Not run)</pre>


<table width="100%" summary="page for show_commit_log"><tr><td>show_commit_log</td><td align="right">R Documentation</td></tr></table>

<h2>
Display recent package software repository commit log entries
</h2>

<h3>Description</h3>

<p>Display recent package software repository commit log entries
</p>


<h3>Usage</h3>

<pre>
show_commit_log()
</pre>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>



<table width="100%" summary="page for slice"><tr><td>slice</td><td align="right">R Documentation</td></tr></table>

<h2>
Low-level SciDB slice operator
</h2>

<h3>Description</h3>

<p>Slice a SciDB array along a coordinate value returning a new SciDB array of lower dimension.
</p>


<h3>Usage</h3>

<pre>
slice(x, d, n, `eval`=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code>  object.</p>
</td></tr>
<tr valign="top"><td><code>d</code></td>
<td>
<p>A character string representation of the coordinate axis to slice along, or
logical or numeric index of the axis.</p>
</td></tr>
<tr valign="top"><td><code>n</code></td>
<td>
<p>The value to slice on.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query and store the reult array.
Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>scidb</code> object of lower dimension.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Build a 5x5 matrix:
x &lt;- build("random()
print(x[])

# Slice the 2nd row (i=1 since SciDB matrices start with zero index by default)
y &lt;- slice(x, "i", 1)
print(y[])

## End(Not run)</pre>



<table width="100%" summary="page for sort-methods"><tr><td>sort-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Methods for Function <code>sort</code> in Package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p>Aggregate a SciDB array object grouped by a subset of its dimensions and/or attributes.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
sort(x, decreasing = FALSE, ...)
## S4 method for signature 'scidbdf'
sort(x, decreasing = FALSE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code> or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>decreasing</code></td>
<td>
<p>A logical value: TRUE means sort in decreasing order.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Optional SciDB-specific aruments (see details below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a new array reference object that represents the sorted version of array
<code>x</code>.  The output array reference has the same shape and number of
attributes as <code>x</code> but the specified attributes appear in sorted order.
The following SciDB-specific parameters are available:
</p>

<ul>
<li><p>attributes(Required) A character vector of attribute names from array <code>x</code> to sort on
</p>
</li>
<li><p>eval(Optional) If true, execute the query and store the result array. Otherwise defer evaluation.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>scidb</code> or <code>scidbdf</code> reference object.</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Create a copy of the iris data frame in a 1-d SciDB array named "iris."
# Note that SciDB attribute names will be changed to conform to SciDB
# naming convention.
x &lt;- as.scidb(iris,name="iris")

# Sort x by Petal_Width and Petal_Length:
a &lt;- sort(x, attributes=c("Petal_Width","Petal_Length"))

## End(Not run)
</pre>



<table width="100%" summary="page for str.scidb"><tr><td>str.scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
Show the structure of a scidb object.
</h2>

<h3>Description</h3>

<p>Print a summary of the dimension structure of a scidb array object.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'scidb'
str(object, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
<p> a scidb array object.
</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p> additional objects for str (see <code>str</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>str</code> does not return anything, for efficiency reasons.  The
obvious side effect is output to the terminal.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>



<table width="100%" summary="page for subarray"><tr><td>subarray</td><td align="right">R Documentation</td></tr></table>

<h2>
Wrapper for SciDB subarray and between operators
</h2>

<h3>Description</h3>

<p>Extract a rectangular subset from a SciDB array (<code>between=FALSE</code>),
or mask all but a rectangular subset empty (<code>between=TRUE</code>).
</p>


<h3>Usage</h3>

<pre>
subarray(x, limits, between=FALSE, `eval`=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code> or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>limits</code></td>
<td>
<p>Either a vector of coordinate bounds in <code>c(low1,low2,...,upper1,upper2,...)</code>
form, or a character string schema, or a SciDB array object. See details.</p>
</td></tr>
<tr valign="top"><td><code>between</code></td>
<td>
<p>If TRUE, form a SciDB between-style query, otherwise use subarray.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>If TRUE, execute the query and store the reult array. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>limits</code> argument can take one of three forms:
</p>

<ul>
<li><p> A vector of coordinate bounds listing the lower bounds for each dimension first
followed by the upper bounds for each dimension, in order (see examples).
</p>
</li>
<li><p> A character string schema that contains a SciDB schema with the same dimensions
as <code>x</code>. Limits will be taken from the schema dimension bounds.
</p>
</li>
<li><p> A <code>scidb</code> or <code>scidbdf</code> object. Limits will be taken from the object's
dimension bounds.
</p>
</li></ul>

<p>Use <code>between=FALSE</code> for the default SciDB subarray operator. Subarray returns a new
zero-indexed array containing the specified rectangular subset. Subarray may move data in
SciDB to the new array zero origin.
</p>
<p>Use <code>between=TRUE</code> for the SciDB between operator. Between does not change the array bounds
or origin. It simply masks cells outside of the specified rectangular region empty. Because between
doesn't move data it's very fast.
</p>
<p>See the examples for a simple comparison of the difference.
</p>


<h3>Value</h3>

<p>A new <code>scidb</code> object.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- as.scidb(iris)
# Extract rows 3--5 (note the indices of the returned results)
subarray(x,c(3,5))[]

# Extract rows 3--5 using SciDB between (note the indices)
subarray(x,c(3,5), between=TRUE)[]

## End(Not run)</pre>



<table width="100%" summary="page for subset-methods"><tr><td>subset-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Methods for Function <code>subset</code> in Package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p>SciDB <code>filter</code> operations.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
subset(X,subset,eval)
## S4 method for signature 'scidbdf'
subset(X,subset,eval)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>X</code></td>
<td>
<p>A <code>scidb</code> or <code>scidbdf</code> object.</p>
</td></tr>
<tr valign="top"><td><code>subset</code></td>
<td>
<p>A character string representing a SciDB filter expression.</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If true, execute the query. Otherwise defer evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perform a SciDB <code>filter</code> operation on a SciDB array. The <code>subset</code> filter expression argument can be any valid SciDB filter operation.
</p>


<h3>Value</h3>

<p>A <code>scidb</code>, <code>scidbdf</code> reference object. </p>


<h3>Note</h3>

<p>We use the function name <code>subset</code> because the R function <code>subset</code> closely matches the native functionality of the SciDB operator named <code>filter</code>. The R <code>filter</code> function is an unrelated timeseries function.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
# Create a copy of the iris data frame in a 1-d SciDB array named "iris."
# Note that SciDB attribute names will be changed to conform to SciDB
# naming convention.
x &lt;- as.scidb(iris,name="iris")

y &lt;- subset(x,"Species='setosa'")

## End(Not run)
</pre>



<table width="100%" summary="page for summary.scidb"><tr><td>summary.scidb</td><td align="right">R Documentation</td></tr></table>

<h2>
Summarize scidb object class.
</h2>

<h3>Description</h3>

<p>Summarize scidb object class. This is not a really useful function yet.
</p>


<h3>Usage</h3>

<pre>
## S3 method for class 'scidb'
summary(x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p> a scidb array object.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>



<table width="100%" summary="page for svd"><tr><td>svd</td><td align="right">R Documentation</td></tr></table>

<h2>
svd
</h2>

<h3>Description</h3>

<p>Compute a partial or full singular value decomposition of a SciDB matrix.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
svd(x, nu, nv)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A scidb object representing a matrix.</p>
</td></tr>
<tr valign="top"><td><code>nu</code></td>
<td>
<p>Optional number of singular values/vectors to compute. See notes below.</p>
</td></tr>
<tr valign="top"><td><code>nv</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three <code>scidb</code> objects corresponding to a matrix of left
singular vectors, a vector of singular values, and a matrix of transposed
right singular vectors, respectively.
</p>


<h3>Note</h3>

<p>If the <code>nu</code> argument is specified, the SciDB <code>tsvd</code> function will be
used and the matrix <code>x</code> may be dense or sparse. Otherwise the full SVD is
computed by SciDB and the matrix <code>x</code> must be dense. The <code>nv</code>
argument is not used and appears in the function signature only
for compatibility with the base <code>svd</code> function. This function always
sets <code>nv</code> = <code>nu</code>.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- as.scidb(matrix(rnorm(500*500),500))
y &lt;- svd(x)
print(y)

## End(Not run)</pre>



<table width="100%" summary="page for sweep-methods"><tr><td>sweep-methods</td><td align="right">R Documentation</td></tr></table>

<h2>Methods for Function <code>sweep</code> in Package <span class="pkg">scidb</span></h2>

<h3>Description</h3>

<p>Return an array obtained from an input array by sweeping out a
summary statistic.
</p>


<h3>Usage</h3>

<pre>
## S4 method for signature 'scidb'
sweep(x, MARGIN, STATS, FUN = "-", eval = FALSE, name)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>a <code>scidb</code> object.</p>
</td></tr>
<tr valign="top"><td><code>MARGIN</code></td>
<td>
<p>a vector of indices giving the extent(s) of 'x' which
correspond to 'STATS'.</p>
</td></tr>
<tr valign="top"><td><code>STATS</code></td>
<td>
<p>the summary statistic which is to be swept out.</p>
</td></tr>
<tr valign="top"><td><code>FUN</code></td>
<td>
<p>the function to be used to carry out the sweep.
(Default is &quot;-&quot;.)</p>
</td></tr>
<tr valign="top"><td><code>eval</code></td>
<td>
<p>(Optional) If TRUE, execute the query and store the reult array.
Otherwise defer evaluation.</p>
</td></tr>
<tr valign="top"><td><code>name</code></td>
<td>
<p>If <code>x</code> is a multi-attribute array, specify the attribute
to work on, default to the first listed array attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>STATS</code> must be a vector whose length matches the dimension size
of the specified <code>MARGIN</code>. Note that this is a more restrictive
condition than the usual R <code>sweep</code> function.
</p>
<p>The default value of <code>FUN</code> is &quot;-&quot;. <code>FUN</code> must be a
quoted binary operator.
</p>


<h3>Value</h3>

<p>A <code>scidb</code> object. </p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>Examples</h3>

<pre>
## Not run: 
set.seed(1)
A &lt;- as.scidb(matrix(rnorm(20),nrow=5))
# Center the matrix
B &lt;- sweep(A, MARGIN=2, STATS=apply(A,2,mean))
# Let's see:
apply(B,2,mean)[]

## End(Not run)
</pre>



<table width="100%" summary="page for tsvd"><tr><td>tsvd</td><td align="right">R Documentation</td></tr></table>

<h2>
tsvd
</h2>

<h3>Description</h3>

<p>Compute a partial singular value decomposition or principal components
of a sparse or dense SciDB matrix.
</p>


<h3>Usage</h3>

<pre>
tsvd(x, nu, tol = 0.1, maxit = 20, tx, v, pca = FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A scidb object representing a matrix.</p>
</td></tr>
<tr valign="top"><td><code>nu</code></td>
<td>
<p>Optional number of singular values/vectors to compute. See notes below.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>(Optional) estimation error tolerance (see details).</p>
</td></tr>
<tr valign="top"><td><code>maxit</code></td>
<td>
<p>(Optional) maximum number of iterations in the method.</p>
</td></tr>
<tr valign="top"><td><code>tx</code></td>
<td>
<p>(Optional) pre-computed transpose of matrix x.</p>
</td></tr>
<tr valign="top"><td><code>v</code></td>
<td>
<p>(Optional) iteration starting vector.</p>
</td></tr>
<tr valign="top"><td><code>pca</code></td>
<td>
<p>Set to TRUE to compute principal components (singular vectors of the
centered matrix).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tsvd</code> method uses Baglama and Reichel's efficient agumented
implicitly restarted Lanczos method for computing a truncated SVD of large
dense or sparse matrices. The method works best for the hard case of close to
square matrices. For matrices where the row and column dimensions are very
different (tall, skinny or short, fat matrices), consider the computationally
cheaper eigenvalue decomposition of the small matrix cross product instead.
</p>
<p>The method is an iterative one.  The <code>tol</code> parameter sets the error
tolerance as defined in the paper and the irlba package vignette available
on CRAN. Smaller values yield more accurate estimations at the cost of more
iterations.
</p>
<p>The method requires multiplication by the matrix <code>x</code> and its
transpose. If you already have the transpose matrix stored in SciDB, you
can optionally specify that in the <code>tx</code> argument.
</p>
<p>The starting vector <code>v</code> defaults to a vector of ones. If this vector
is near the matrix null space then the algorithm may not converge. Specify
an alternate starting vector as required.
</p>
<p>Set the <code>pca</code> argument to <code>TRUE</code> to indicate that you desire
principal components. The method will efficiently compute the singular
vectors of the centered matrix in that case, without explicitly forming
it to preserve sparsity.
</p>


<h3>Value</h3>

<p>A list of three <code>scidb</code> objects corresponding to a matrix of left
singular vectors, a vector of singular values, and a matrix of transposed
right singular vectors, respectively.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis&lt;blewis@paradigm4.com&gt;
</p>


<h3>References</h3>

<p>&quot;Augmented Implicitly Restarted Lanczos Bidiagonalization Methods&quot;,
J. Baglama and L. Reichel, SIAM J. Sci. Comput. 2005.</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- as.scidb(matrix(rnorm(500*500),500))
y &lt;- tsvd(x)
print(y)

## End(Not run)</pre>



<table width="100%" summary="page for unbound"><tr><td>unbound</td><td align="right">R Documentation</td></tr></table>

<h2>
Return a bounded or unbounded version of a SciDB array
</h2>

<h3>Description</h3>

<p>Return a new sparse SciDB array identical to the input array but with each
dimension upper bound set to '*' (unbound) or maximum non-empty coordinate
(bound).
</p>


<h3>Usage</h3>

<pre>
unbound (x)
bound (x)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>A <code>scidb</code>  or <code>scidbdf</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new sparse <code>scidb</code> or <code>scidbdf</code> object.
</p>


<h3>Author(s)</h3>

<p>B. W. Lewis &lt;blewis@paradigm4.com&gt;
</p>


<h3>See Also</h3>

<p><code>scidb</code>
</p>


<h3>Examples</h3>

<pre>
## Not run: 
x &lt;- build("i+j", c(10,10), type="double")
y &lt;- unbound(x)
z &lt;- bound(y)
# Now compare schema of x, y, and z:
schema(x)
schema(y)
schema(z)

## End(Not run)</pre>


<script>
/**
 * @author Louis Stowasser <louisstow@gmail.com>
 * License: MIT
 */
function generateTOC (rootNode, startLevel) {
  var lastLevel = 0;
  startLevel = startLevel || 1; //which H# tag to start indexing.
  
  var html = "<ul>";
 
  //loop every node in rootNode
  for (var i = 0; i < rootNode.childNodes.length; ++i) {
    var node = rootNode.childNodes[i];
  
	//skip nodes that aren't <H#> tags
  	if (!node.tagName || !/H[1]/.test(node.tagName)) {
  		continue;
  	}
  
  	var level = +node.tagName.substr(1);
  
	//only parse at the start level
  	if (level < startLevel) { continue; }
  
	//if the <H#> tag has any children, take the text of the first child
	//else grab the text of the <H#> tag
  	var name = node.innerText;
  	if (node.children.length) { name = node.childNodes[0].innerText; }
  	
  	//skip this node if there is no name
  	if (!name) { continue; }
    
   	//create a string that can be used for an anchor hash based
    	//on the name but without dots or spaces
  	var hashable = name.replace(/[\.\s]/g, "-");
    
    	//set the id of the <H#> tag to this hash
  	node.id = hashable;
  
   	//generate the HTML
  	if (level > lastLevel) {
  		html += "";
  	} else if (level < lastLevel) {
  		html += (new Array(lastLevel - level + 2)).join("</ul></li>");
  	} else {
  		html += "</ul></li>";
  	}
  
  	html += "<li><a class='lvl"+level+"' href='#" + hashable + "'>" + name + "</a><ul>";
  	lastLevel = level;
  }
 
  html += "</ul>";
  return html;
}
 
window.onload = function()
{
  document.getElementById("nav").innerHTML = generateTOC(document.getElementById("content"));
};
</script>
</body>
</html>
